
%----------------------------------------------------------------------------
\chapter[A Slime nyelv]{\href{https://github.com/Hollo1996/SlimeAnUTLE}{A Slime nyelv}\footnote{\url{https://github.com/Hollo1996/SlimeAnUTLE}}}
\label{sec:Slime}
%----------------------------------------------------------------------------
\section{Bemutatkozás}
\label{sec:SIntro}
%----------------------------------------------------------------------------
A szakdolgozatomban a \texttt{Slime} nyelv kidolgozásával foglalkoztam, amely egy más nyelvek fölé szánt univerzális bővítmény, ami templatelést használ.
Fontosnak tartottuk, hogy legyen neve annak a szemléletnek, amit a Slime képvisel, hogy könnyebben lehessen beszélni később a Slime és a templater enginek közötti különbségről. 
Mivel ilyen megoldás nem létezett eddig, ezért mi jöttünk föl az \texttt{Universal Templater Language Extention} avagy \texttt{UTLE} kifejezéssel.


A fejlesztés során az IRTG kiegészítése volt az elsődleges cél, de ezt a sok iteráció alatt kinőtte a koncepció. 
Ennek több oka volt: először is az IRTG-nek a legtöbb hiányossága későbbi fejlesztés során megszűnhet a nyelv későbbi kiegészítésével (lásd~\ref{sec:shortcomming}).
A kiegészítéshez a belső működés módosítására nincs feltétlenül szükség. 
Az Alto-t ugyan viszonylag könnyű kiegészíteni és módosítani, mivel kellően objektum orientált és nyílt forráskódú,
de állandó fejlesztés alatt áll, ezért a forráskód módosítása és kiegészítése is verziókövetést igényel. 
A függőséggel arányosan nő a karbantartási költség. 
Az Alto fejlődésével sok kódunk feleslegessé válik, ezért külső megoldást igényel. 
 
A Slime küldetése az, hogy növelje a kódok átláthatóságát, strukturáltságát és kiirtsa a feleslegesen repetitív kódrészeket.

Az univerzalitást szem előtt tartva egy olyan módszert kell alkalmazni, ami független a kiegészített nyelv fordítójától és szintaxisától, erre a legpraktikusabb megoldás a template-elés. 
Először a kiegészített nyelvre generáljuk a kódot és azt futtatjuk a nyelv saját fordítójával. 
Ez ugyan egy új lépést jelent, de párhuzamosítással áttetszővé válhat a Slime könnyű súlyának köszönhetően. 
Az ötlet persze nem teljesen egyedi, eddig is sokféle template processzort és engine-t használtak (lásd ~\ref{sec:SAlternatives}) adatleíró nyelvekhez. 
Ugyanakkor ezek inkább könyvtárak, mintsem nyelvek: legtöbbször egy magasabb szintű nyelvből lehet kezelni őket, amiknek a támogatása is szükséges. 
Céljuk tipikusan HTML vagy CSS kódok folytonos manipulációja. 
A Slime-ból sem nehéz könyvtárat készíteni, de hosszú távú célja az abszolút önállóság. 
Kerüli a függőséget minden felette lévő rétegtől is.

A réteges architektúra és egyirányú viszony miatt a kiegészített nyelvre \texttt{alárendelt nyelv}ként (subordinate language) fogok hivatkozni.
A template-ek esetében megszokott terminológia \texttt{master document}ként hivatkozik az alárendelt nyelv sablonjaira, ezzel ellentétben \texttt{alárendelt dokumentum}ként (subordinate document) fogok hivatkozni rá. 

A Slime még egy fiatal nyelv, így benne is megjelennek természetesen az elkerülni kívánt jelenségek. 
Nem mindig elkerülhető a kódok repetitivitás, és a zárójelezések miatt is sok a felesleges karakter. 
Nem haladja meg azt a funkcionalitást, amire tervezve lett, közel sem Turing-teljes. 
Nem tartalmazza a legalapvetőbb aritmetikai műveleteket sem. 
Csak a template-eléshez és strukturáláshoz szükséges funkciókat implementálja (lásd ~\ref{sec:SStatesOfDevelopment}). 
További fejlesztést igényel és a szintaxis letisztulását.
Ezekre a problémákra és tervezett megoldásaikra a későbbiekben fogok kitérni. 
A Slime így is jelentős fejlődést jelent olyan nyelvek számára, amelyekben ezek a problémák sokkal nagyobb mértékben jelentkeznek. 
Ilyen az IRTG, HTML, XML és ironikusan annak az ANTLR-nek a \texttt{lexer} és \texttt{parser} nyelvtan leíró nyelve, amit a Slime jelenlegi fordítója használ (lásd ~\ref{sec:SEIRTG}). 
Tehát végső soron a Slime egy olyan nyelv, ami saját magának az implementálását is határozottan könnyebbé tette volna.


%----------------------------------------------------------------------------
\section{A tervezés szempontjai}
\label{sec:SDesign}
%----------------------------------------------------------------------------
A Slime a következőkre összpontosít:
\begin{itemize}
\item alárendelt és fölérendelt nyelvtől való függetlenség,
\item könnyű súly és sebesség,
\item platformfüggetlenség,
\item könnyű bővíthetőség,
\item esztétikum és egyéniség,
\item kód átláthatósága és könnyen érthetősége,
\item szabad tördelhetőség akár több fájlba,
\item enyhe tanulási görbe,
\item hatékony programozás az alárendelt nyelven.
\end{itemize}

Eddig a nyelvektől való függetlenséget emeltük ki. 
E célból a nyelv külön fordítót, template-elést és szöktetést használ.

A könnyű súlyt könnyen parszolható szintaxissal és egyszerű műveletekkel támogatja. 
Később a túlsúlyos külső könyvtárak elhagyása is sokat fog segíteni.

A platformfüggetlenség okán Kotlinban készült az első fordító, ami JVM-en fut. 
A könnyen bővíthetőséget modularitással és egységes szintaxissal támogatja.

Az esztétikum és felismerhetőség elsősorban a szintaxisra vonatkozik. 
Cél az átláthatóság. 
Fontos, hogy szép kódunk legyen, amiben a nyelvi elemek jól felismerhetőek.
Ugyanakkor az is fontos, hogy a Slime kódja kitűnjön az alárendelt nyelv kódjából. (lásd ~\ref{sec:SBaseSyntax})

A szabad tördelhetőségben segítenek sokat a zárójelek, változók és az importálás megvalósítása. (lásd ~\ref{sec:SEIRTG}) 
A könnyen tanulhatóságot a beszédes, de tömör jelölések, kevés, de sokoldalú művelet és következetes működés, valamint a kódok átláthatósága is segíti.

A hatékony programozást a tömörített kifejezések és a szükségtelen jelölések elhagyása segítik.

Sokszor kellett kompromisszumokat kötni a szempontok között, ezeket a döntéseket ugyanakkor legtöbbször inkább elkerültük. 
A nyelv sok zárójelet tartalmaz a könnyű parszolás és átláthatóság érdekében, ugyanakkor van lehetőség a csukó zárójelek esetenkénti elhagyására.
Sok nyelv az adatot elkülöníti a kódtól. 
Slime-ban a kód tartalmazza a templatet, de külön fájlba szervezéssel elkülöníthetőek. 
Más templater engine-ek könyvtáraival ellentétben nem a Slime-ba ágyazzuk az alárendelt nyelv kódját, hanem  
az alárendelt nyelv kódjába ágyazzuk a Slime-ot, így a Slime használatának mennyisége teljesen opcionális. 
A felhasználó hagyatkozhat teljesen a Slime-ra, vagy használhatja csak a legrepetitivebb kódrészek esetén. 
A Slime esetén akár saját maga is könnyen lehet az alárendelt nyelv, ezt a szöktető zárójelek nagyban segítik. 
A reguláris kifejezések(RegEx) esetén például csak egy karaktert lehet szöktetni, így RegEx-szel RegEx-ben keresni elég nehézkes.
Slime esetében az alárendelt Slime kód részeket egyszerűen \{” ”\} szöktető zárójelek közé rakjuk.


%----------------------------------------------------------------------------
\section{Alternatívák template-elésre }
\label{sec:SAlternatives}
%----------------------------------------------------------------------------
Rengeteg alternatíva létezik template-elés terén az itt felsoroltakon kívül is. 
Azt mutatom be, hogy a ma fellelhető megoldások miben térnek el a Slime-tól.
Nem kívánom a nyelveket kritizálni.
Más a céljuk, így természetes, hogy nem tudnak a Slime célkitűzéseinek eleget tenni.

%----------------------------------------------------------------------------
\subsection[Mustache]{\href{https://Mustache.github.io}{Mustache}\footnote{\url{https://Mustache.github.io}}}
\label{sec:Mustache}
%----------------------------------------------------------------------------
A Mustache az egyik legtöbb forrással rendelkező templater könyvtár.
Tömbnyire HTML manipulációra használják.
Elérhető többek között Ruby, JavaScript, Python, PHP, Perl, Objective-C, Java, C\# /.NET, Android, C++, Go, Lua, Scala, Delphi, R, C nyelveken.
A 46 nyelv teljes listája elérhető a hivatalos GitHub oldalukon.
A Kotlin ugyan még nem szerepel benne, de ami Java alatt elérhető, az Kotlin alatt is.
Jól működik többek között a TextMate, Vim és Emacs szövegszerkesztőkkel.

Ún. \texttt{logic-less template}-eket használ, vagyis elkülöníti a logikát és a a sablonokat.
A mezőket dupla kapcsos zárójelekkel jelöli, például \textit{Dear \{\{ name \}\}}.
A mezőkre \texttt{tag}-ként hivatkozunk esetében.
A \texttt{name} a tag kulcsa.
Ezt a kulcsot fogom használni a későbbi példáimban is.

A template-be kulcs-érték párokat lehet beszúrni.
Minden tag-be az ő nevéhez tartozó adat szúródik be.

Több fajtája létezik a tag-eknek:
\begin{itemize}
\item \emph{Variables:}
Ezek a legalapvetőbb tag-ek.
Amikor a template \texttt{name} kulcsú tag-jébe szúrunk be, akkor az összesbe szúrunk be.
Alapvetően szöktetve vannak a HTML-ből.
Például a \textit{<b>GitHub</b>} helyett \textit{\& lt;b\& gt;GitHub\& lt;/b\& gt;} kerül a kódba.
Ha szeretnénk, hogy ne legyenek szöktetve, akkor \textit{\{\{\{ name \}\}\}} vagy \textit{\{\{\& name \}\}} módra kell megadnunk őket.
Például ha a \textit{\{\{\{name\}\}\}} vagy \textit{\{\{\& name\}\}} mezőbe szúrjuk be a \textit{<b>GitHub</b>} szöveget, akkor az \textit{<b>GitHub</b>}ként is lesz beszúrva.
\item \emph{Sections:}
Egy section tartalma egyszer vagy többször is megjelenhet.
Elejét \textit{\{\{\# name \}\}} és végét \textit{\{\{/ name \}\}} módon jelöljük.
A kettő között egy sablonrészlet található.
Egy boolean értéket vagy adatlistát lehet a \texttt{section} mezőbe szúrni.
Ha false-t vagy üres listát kap, akkor nem jelenik meg.
True esetén megjelenik egyszer, és a tagjeibe a kulcsukhoz tartozó adatot szúrja be.
Nem üres lista esetén a belső sablonba a lista minden elemét beszúrja és az eredményeket egymás alá írja ki.
Ha egy paraméter nélkül hívható objektumot adunk át neki, akkor azt meghívja és a kimenetét szúrja be a Section helyére.
Ez lehet lambda kifejezés, funktor vagy function is.
\item \emph{Inverted Sections:}
Elejét \textit{\{\{$\cap$ name \}\}} és végét \textit{\{\{/ name \}\}} módon jelöljük.
Akkor jelennek meg, ha a kulcsuk a kapott adatban nem létezik, false vagy üres lista.
Ez például hiányzó kulcsok esetén alkalmas hibaüzenet vagy más visszajelzés megjelenítésére.
\item \emph{Comments:}
Mustache-ben kommentet \textit{\{\{! ignore me \}\}} formátumban írhatunk.
Ezeket bárhol kezdhetjük a szövegben, de nem kerülhetnek tag-be.
\item \emph{Partials:}
A \textit{\{\{> name\}\}} formátumban adhatóak meg.
Rekurzívak is lehetnek, ha nem tartalmaznak végtelen ciklust.
Ezzel valósítja meg a Mustache az importálást.
A fenti példa a name nevű Mustache fájl tartalmát jelöli.
\item \emph{Set Delimiter:}
Ezzel a funkcióval új jelölés vezethető be a dupla kapcsos zárójelek helyett.
Például a \textit{\{\{=<\% \%>=\}\}} a \textit{\{\{ name \}\}} formátumot \textit{<\% name \%>}-re cseréli.
Ez hasonló módon vissza is állítható: \textit{<\%=\{\{ \}\}=\%>}
Ez a Mustache megoldása arra, hogy váratlan szintaxisú környezetben is jól használható legyen.
\end{itemize}

Összegezve, a Mustache egy egyszerű, kreatív és egyszerű templater engine.
Ugyanakkor külső vezérlést igényel működéséhez és HTML-ekre van szakosodva.
Nincs szöktetés, csak a tag-ek jelölése állítható dinamikusan.
Ez ugyanakkor egy olyan képesség, amivel a Slime nem rendelkezik (még). 


%----------------------------------------------------------------------------
\subsection[Jade]{\href{https://pugjs.org/api/getting-started.html}{Jade}\footnote{\url{https://pugjs.org/api/getting-started.html}}}
\label{sec:jade}
%----------------------------------------------------------------------------
A Jade az egyik legelterjedtebb templater nyelv.
2017-ban át lett nevezve \texttt{Pug}gá és az új források is már így hivatkoznak rá.
Ennek ellenére legtöbben még az eredeti nevén ismerik.

Erősen HTML-re van szakosodva.
A HTML nyitó jeleket egyszerűbben lehet benne írni, és a csukó jel teljes mértékben elhagyható.
A tag-ek jelölésére a \#\{ name \} jelölést használja.

Attribútumok:
\begin{verbatim}
<a ...> ... </a> 
\end{verbatim}
helyett 
\begin{verbatim}
a(...) ...
|
|
\end{verbatim}
Utóbbi esetben a két \textit{'|'} zárja az \textit{a}-t.

Elágazás is lehetséges benne: body(class=authenticated ? 'authed' : 'anon')

A zárójelekben az elemeket enterrel tagolja:
\begin{verbatim}
input(
  type='checkbox'
  name='agreement'
  checked
)
\end{verbatim}

"-" jellel JavaScript is ágyazható bele.

Class adható meg egyszerűen így is:
\begin{verbatim}
a.button
\end{verbatim}

Összegezve a Pug egy nagyon fejlett és összetett nyelv.
Erősen JavaScriptre és HTML-re van szakosodva, a hatékony kódolást helyezi előtérbe az átláthatósággal szemben.


%----------------------------------------------------------------------------
\subsection[Underscore Templates]{\href{https://underscorejs.org}{Underscore Templates}\footnote{\url{https://underscorejs.org}}}
\label{sec:underscore}
%----------------------------------------------------------------------------
Onnan kapta a nevét, hogy minden függvény az \_ névtérből érhető el.
(Én magam is sokszor használtam saját hasonló nevű Java handler osztályokat, hogy átláthatóbbak legyenek a műveleteim. 
\_ nevű osztályokat persze a Java újabb verzióiban már nem lehet létrehozni.)
A hivatalos oldalán is JavaScript library-nek hívják az \textit{Underscore Templates}-et.
Más alatt nem is elérhető és nem kíván teljes nyelv lenni.
Az Underscore nem csak templatelésre való, hanem a JavaScript egy általános kiegészítése, több mint 100 függvényt kínál fel.
Funkcionális segédként tartalmaz map-et, filter-t és invoke-ot.
Ezen kívül tartalmaz function binding-ot, JavaScript templating-et, quick index-ek készítését és deep equality testing-et.

A template-elésre is számos ügyes megoldást tartalmaz.
<\% name \%> formátumban jelöli a mezőket.
Ennek is több verziója van, amit a mezőt megelőző karakter jelöl:
\begin{itemize}
\item \emph{<\%=name\%>:}
Ezt interpolate-nak hívják, ez a legalapvetőbb mező.
A beszúrt adatot egy az egyben beszúrja.
\item \emph{<\%-name\%>:}
Ezt escape.nek hívják.
A beszúrt adat \texttt{\& < > " ' /} karaktereit HTML skip-eli.
\item \emph{<\%name\%>:}
Ezt evaluate-nek hívják, JavaScript kódrészleteket lehet beleszúrni, például egy forEach-et, ami egy listányi adaton végig megy és mindegyiket beleszúrja a mezőkbe, mindegyik beszúrással új példányt hozva létre.
Alkalmas elágazások implementálására is.
Képes metadatokat elérni.
\end{itemize}

A szintaxis is állítható:\_ .templateSettings = \{interpolate : /$\backslash$ \{$\backslash$\{(.+?)$\backslash$\}$\backslash$\}/g \};

(érdekesség: A Mustache hivatalos példáiban azt mutatják be, hogy hogyan lehet az Underscore mező nyitó és csukó zárójeleit használni a Mustache helyett a \textit{\{\{=<\% \%>=\}\}} segítségével. Mint feljebb látható, az Uderscore hivatalos példáiban épp a Mustache nyitó és csukó zárójeleire váltunk.)

Az Underscore a Mustache és a Jade (Pug) szemléletét ötvözi.
Többféle mezőt használ, de megengedi a JavaScript elemek beszúrását, így vállalja, hogy a JavaScripttel erős függőségben legyen.
JavaScript alatt ez a legelőnyösebb megoldás: a lehető legkevesebb új információ mellett lehet hatékonyan template-elni.
Engedi a szintaxis átállítását is, ami mindig hasznos, ha nincsen a nyelvben hatékony skipelés.

%----------------------------------------------------------------------------
\subsection[Embedded JS Templates]{\href{https://github.com/mde/ejs}{Embedded JS Templates}\footnote{\url{https://github.com/mde/ejs}}}
\label{sec:embedded}
%----------------------------------------------------------------------------
Ez is egy könyvtár.

Jelölése az Underscore-ra hasonlít. Tele van hasznos funkciókkal.
\textit{<\% \%>}-tel JavaScript ágyazható vele, amivel könnyen megvalósíthatóak vezérlési szerkezetek (ciklusok, if-ek, stb.).
\textit{<\%= \%>} szöktetett beszúrás végezhető. 
\textit{<\%-  \%>} szöktetés nélküli beszúrás.
Tehát pont fordítva, mint az Underscore esetében.
Newline-trim mód, ha \textit{-\%>} -kal zárjuk.
\textit{<\%\_  \_ \%>}-szel Whitespace-trim mód a Control Flow számára. 
Saját határoló jelek is bevezethetőek (pl.: \textit{<? ?> <\% \%>} helyett).

további jelölései:
\begin{itemize}
\item \emph{\textit{<\%} :} 'Scriptlet' tag a control-flow-nak.
\item \emph{\textit{<\%\_} :} 'Whitespace Slurping' Scriptlet tag, elhagy minden whitespace-t maga előtt.
\item \emph{\textit{<\%=} :} beszúrja az adatot HTML szöktetve.
\item \emph{\textit{<\%-} :} beszúrja az adatot HTML szöktetés nélkül.
\item \emph{\textit{<\%\#} :} kommentelés
\item \emph{\textit{<\%\%} :} Egy \textit{'<\%'}-t ad vissza
\item \emph{\textit{\%\%>} :} Egy \textit{'\%>'}-t ad vissza
\item \emph{\textit{\%>} :} Egyszerű csukó tag
\item \emph{\textit{-\%>} :} Trim-mode ('newline slurp') tag, az utána jövő új sor karaktereket elhagyja.
\item \emph{\textit{\%>} :} 'Whitespace Slurping' csukó tag, elhagy minden whitespace karaktert maga után.
\end{itemize}

Nagy hangsúlyt fektet a whitespace-ek kezelésére.

%----------------------------------------------------------------------------
\subsection[HandlebarsJS]{\href{https://handlebarsjs.com}{HandlebarsJS}\footnote{\url{https://handlebarsjs.com}}}
\label{sec:hjs}
%----------------------------------------------------------------------------
Ez a megoldás a Mustache működéséhez és jelöléseihez közelít.
Handlebar-ként hivatkozunk a HandlebarsJS mezőire.
A böngészőbe <script> blokkban lehet bevinni.


Handlebar-oknak sok fajtája létezik:
\begin{itemize}
\item \emph{\textit{\{\{ name \}\}} :} 
Alap Handlebar.
HTML szöktetést használ.
\item \emph{\textit{\{\{\{ name \}\}\}} :} 
Handlebar HTML szöktetés nélkül.
\item \emph{\textit{\{\{\# list name\}\} ... \{\{/list\}\} }:} 
blokkos kifejezés.
Például ebben az esetben egy nema címkéjű lista.
Egy listányi adatot beleszúrva mindegyikkel elvégzi a beszúrást és egymás alá listázza az eredményt.
\item \emph{\textit{\{\{! ... \}\} , \{\{--! ... --\}\}} :} kommentelés két formátuma.
\end{itemize}


%----------------------------------------------------------------------------
\subsection[Smarty]{\href{https://www.smarty.net}{Smarty}\footnote{\url{https://www.smarty.net}}}
\label{sec:smarty}
%----------------------------------------------------------------------------
A Smarty egy rendkívül fejlett templater engine.
Mint a legtöbb templater, PHP-ra és  HTML-re szakosodott.
A blokkjait kapcsos zárójellel határolja.

Számos funkcionalitást lehet vele a template-en belül jelölni.
Ezeknek a részletezése nem fér bele a szakdolgozat kereteibe, ezért csak a szintaxis szemléltetésének céljával sorolok fel alapvető nyelvi elemeket:

\begin{itemize}
\item \emph{variable: }
\textit{\{\$ name \}}
A Smarty mezői, ők maguk is tartalmazhatnak más változókat. 
\item \emph{functions: }
\textit{\{funcname attr1="val1" attr2="val2"\}}
\item \emph{komment: } 
\textit{\{* This is a comment *\}}
\item \emph{import: } 
\textit{\{include 'page\_footer.tpl'\}}
\item \emph{cycle: }
\begin{verbatim}
<tr class="{cycle values="odd,even"}">
   <td>{$data[rows]}</td>
</tr>
\end{verbatim}
A ciklus megvalósítása. 
Végigiterál az értékeken.
\item \emph{upper: } 
\textit{\{\$name|upper\}}
Nagy betűkkel szúrja be a szöveget.
\item \emph{foreach: } 
\begin{verbatim}
{foreach $nameList as $name}
    <li>{$name}</li>
{/foreach}
\end{verbatim}
Loops throw the whole array.
Egy fejlett megoldás, ami sokféleképpen használható, nem részletezem a szakdolgozat kereteiben.
\item \emph{display: } 
Kiír konzolra egy template-et.
\end{itemize}

Összefoglalva a Smarty minden műveletet kapcsos zárójelekbe zár.
Ezeket figyelmen kívül hagyja, ha whitespace-be vannak foglalva.
A föggvények nevét a kapcsos zárójelekkel jelöli.
Igyekszik mindent saját nyelvi elemekkel megoldani.
Érdekes, hogy a Smarty ismerete nélkül a Slime szintaxisa is ebbe az irányba mozdult el, de a Slime ennél egy sokkal egyszerűbb megközelítést követ.

%----------------------------------------------------------------------------
\section{A Slime alapjai}
\label{sec:basics}
%----------------------------------------------------------------------------
A Slime egy letisztult nyelv, összesen tizenegy példányosítható típust és tíz műveletet tartalmaz. 
Egységes és csak erősen indokolt esetekben tér el a természetes, bevett megoldásoktól.
A továbbiakban a szintaxist, típusokat és műveleteket összetettség szerinti sorrendben igyekszem leírni.
\begin{itemize}
\item Az első alfejezetben a szintaxis alapjait mutatom be.
\item A második alfejezetben a típusok közös ősével folytatom.
\item A harmadik alfejezetben a tároló típusok őséről írok.
\item A negyedik alfejezetben a sablonok szintaxisáról és alkotóelemeiről írok.
\item Az ötödik alfejezetben bemutatom a műveleteket és egyszerű eseteiket.
\item A hatodik alfejezetben mutatom be a tároló típusokat.
\item A hetediktől a kilencedik alfejezetig a műveletek összetettebb, tároló osztályokat is használó eseteit mutatom be.
\item A tizedik fejezetben mutatom be a Refe típust, ami a szakdolgozat egyik legfontosabb funkcionalitását valósítja meg.
\item A tizenegyedik fejezetben a haladó szintaxisról írok.
\item Végezetül a tizenkettedik fejezetben mutatom be a Name típust, ami a változók neveinek kezelését teszi lehetővé.
\end{itemize}
 

%----------------------------------------------------------------------------
\subsection{Alapvető szintaxis}
\label{sec:SBaseSyntax}
%----------------------------------------------------------------------------
A szintaxis terén volt a legnehezebb megtalálni az egyensúlyt a tömörség, az átláthatóság és a tanulhatóság között. 
Fontos volt az, hogy a jelölések már bevettek legyenek, vagy következetesek, hogy könnyű legyen megtanulni. 
De az átláthatósághoz az is fontos volt, hogy a jelölések egyediek legyenek.

A bevett jelölésekhez népszerű templater enginek, a Kotlin és más C alapú nyelvek szolgáltak alapul.
\begin{itemize}
\item \emph{sablon nyelvek:}
A Smarty-hoz hasonlóan (lásd~\ref{sec:smarty}) a parancsokat az alárendelt kódba ágyazzuk.
Minden művelet kapcsos zárójelbe kerül, hogy elkülönüljön az alárendelt kódtól.
Ez rendes tördelés mellett az átláthatóságot is segíti, és használatával a műveleti sorrend is egyértelmű. 
A Mustache-hoz hasonlóan (lásd~\ref{sec:Mustache}) a blokkok típusát a blokkon belül jelöli egy-két karakterrel.
Ez is segíti az alárendelt kódtól való elkülönülést.
Slime esetén a csukó zárójel előtt is jelöljük a blokk típusát, az átláthatóság kedvéért.
\item \emph{Kotlin:}
Deklarációnál a név, típus, érték sorrendet követi, ekkor a nevet és a típust kettősponttal választja el.
\item \emph{C alapú nyelvek:}
A több parancsot tartalmazó zárójelekben(lásd bővebben ~\ref{sec:SAdvaSyntax}) a parancsokat pontosvesszővel választjuk el.
A zárójeleken belül az attribútumokat vesszővel és kettősponttal választjuk el.
A \textit{':'}-tal tagolja a függőségben lévő attribútumokat és a \textit{','}-tal a függetleneket. 
Például a kulcs-érték párokat \textit{':'} köti össze.
Ha az attribútumok között összetettebb hierarchia van, azt a kettőspont mellett kerek zárójelek is jelölik. 
A referenciát a \textit{'\&'} karakter jelöli.
\end{itemize} 
Egyes műveletek esetén a főbb attribútumhalmazokat saját operátorral is elválasztjuk, például deklaráció során a létrehozott változó metaadatait leíró részt (nevek és típus) egy \textit{“:=”} zárja.
A következő fejezetek példái jól szemléltetik ezeket is.

%----------------------------------------------------------------------------
\subsection{Vari őstípus}
\label{sec:SVariSuper}
%----------------------------------------------------------------------------
A Slime egy erősen típusos nyelv.
Nincsen benne öröklődés, de van két absztrakt őstípus.
A Slime összes típusának közös absztrakt őstípusa a Vari(variable).

Minden Vari példánynak lehet akár több, akár nulla neve.
Ezek a nevek az angol abc kis- és nagybetűit, alulvonást és számokat tartalmazhatnak, de számokkal nem kezdődhetnek.
Egy névtelen változó csak az őt birtokló változókon keresztül érhető el.
A több név több esetben is hasznos lehet, például az éppen többet használt változókat hivatkozhatjuk a rövidebb nevükön.
Ritkább használat esetén pedig hivatkozhatjuk őket a hosszabb nevükön.
Tömören programozunk, és mindig mindent elérünk egyszerre.
A programozási környezetek gyakran tartalmazzák az automatikus rendezés funkciót.
Egy Slime környezet lehetővé tehetné, hogy a változó meghivatkozásainál a nevét a leghosszabbra cseréli.
Így a programozó gyorsan kódol és néhány gombnyomásra érthetővé teheti a gyorsan leírt kódot.
Vagy például többen dolgoznak egy projekten, de mindenki más terminológia szerint dolgozik.
Ilyenkor mindenki hozzáadhatja a változókhoz azt a nevet, ami neki kényelmesebb.

A Slime-ban van importálás.
Az importált fájl változói a fájl változójának nevén, mint namespace-en keresztül érhetőek el.
Például az \texttt{f1} néven importált fájl \texttt{v1} változója \texttt{f1.v1} néven érhető el.
Ez fontos ahhoz, hogy elkerülhessük a váratlan névütközéseket.
Egy változóhoz nevek később is adhatóak a Name típus segítségével (lásd~\ref{sec:SName}).
Az új nevek annak a Slime fájlnak a namespace-éhez fognak tartozni, amelyikben hozzá lettek adva az adott változóhoz. 
Így lehet például egy importált fájl változóit könnyebben elérhetővé tenni.
Ha egy név már foglalt az adott fájlban, akkor egyszerűen felülíródik.
Erről persze a programozó kap visszajelzést futtatáskor.
A több név gyakorlatilag a referenciákat helyettesíti, ugyanakkor ez egy sokkal magasabb szintű megoldás.
A változó is tudja, hogy honnan érhető el és milyen név szerint.

Minden Vari-nak létezik a következő négy attribútuma:

\begin{itemize}
\item \emph{names:} 
A változó nevei a fájl elérése szerint.
\item \emph{self:} 
A változó maga. 
Ez a "referencia" helyett magára a változóra hivatkozik.
Ha egy változó közvetlen elérhető, akkor a meghivatkozása nem tartalmaz pontot.
Bizonyos esetekben a parszer az ilyen meghivatkozást \texttt{Name} típusú változónak tévesztheti, például ha egy listát készítünk, és vesszővel felsoroljuk az elemeit (Lásd fejezet~\ref{sec:SContDecl}).
Ilyenkor a \texttt{self} attribútummal egyértelműsíthetjük, hogy a változó elérésre gondoltunk, és nem \texttt{Name} típusú változóra. 
\item \emph{copy:}
Ez az attribútum a változóból egy új másolatot ad vissza név nélkül.
Későbbiekben a copy-ból három féle fog létezni. 
A copyS sekély, a copyD mély és a copy\{\$integer\$\} adott mélységű másolatot fog visszaadni.
\item \emph{type:}
Ez az attribútum jegyzi a változók típusát.
Egy Type típusú változó, ami a változó attribútumait jegyzi az itt felsorolt négy kivételével.
Ez a változó név szerint nem érhető el, csak vele rendelkező osztályokból.
Ennek célja, hogy az alaptípusok ne szennyezzék a kiindulási fájl namespace-ét.
\end{itemize}

Ezen kívül egyes típusoknak vannak további attribútumai, de metódusai nincsenek. 
Csak a mindenkin végrehajtható operációkat kezelik le másképp. 
Ez a négy operáció a:
\begin{itemize}
\item \emph{deklaráció:} 
Egy új változó létrehozása az adott típussal.
Nem csak ezzel a művelettel lehet változót létrehozni, de ez a legsokoldalúbb módszer rá.
Minden típus példányosítható vele.
A változó nevei is megadhatóak egyből.
Képes más műveletek kimenetéből példányosítani.
\item \emph{törlés:} 
Törli egy változónak az egyik nevét, vagy elveszi egy birtokosától.
Egy változó csak akkor szabadul fel, ha az összes nevéről törlik és senki sem birtokolja.
Ha egy változó self attribútumára hívnak törlést, akkor az összes neve szerint törli magát az összes Slime fájlból, ugyanakkor a birtokosai továbbra is elérik.
Akkor lehet igazán hasznos, ha nagyon nagy szöveghalmazzal foglalkozunk, vagy le akarunk tiltani ideiglenesen létrehozott neveket.
\item \emph{hozzáadás:}
A hozzáadás egy sokoldalú művelet. 
Ez végez ugyanis minden konkatenációt, beszúrást és deklaráció utáni értékadást.
\item \emph{kiterjesztés:}
A kiterjesztés a C nyelvek ToString műveletének felel meg, szöveggé alakítja a változókat.
Ezen kívül az alárendelt nyelv kódjába ágyazva beilleszti a változó szöveges értékét az alárendelt nyelv kódjába, ebből az extra funkcionalitásból származik a neve is.
\end{itemize}

Ezek a műveletek nyilvánvaló alapkövetelményei a sablonkezelésnek. 
Ha nem tudunk sablonokat létrehozni, beszúrni egymásba és kiírni, akkor nem látjuk el a nyelv alapfunkcióit.
A törlés persze másodlagos, de igazán nagy adathalmazok esetén hasznos lehet. 
Mivel Slime-ban nincs garbage collector, nem szabadulnak fel az adatok maguktól.
A parancsok sorrendje sem kerül optimalizálásra.
A törlés az ideiglenesen a változókhoz adott nevek törlésének is kényelmes módja.
Nagy adatok esetén ugyanolyan fontos a változók hatékony tárolása és kezelése is, ebben segítenek a tároló osztályok.
Az operátorok szintaxisát és pontos működését később részletezem. 


%----------------------------------------------------------------------------
\subsection{Cont őstípus}
\label{sec:SContSuper}
%----------------------------------------------------------------------------
A tároló típusok közös absztrakt őse a Cont(container) osztály.
Működésük nagyban eltér, de vannak közös attribútumaik:
\begin{itemize}
\item \emph{cont:} 
Minden Cont változó tárolhat más Vari változókat.
Ezek listába (List) szervezve a változó cont attribútuma.
A lista minden lekérdezéskor újra példányosul.
\item \emph{iter:} 
Minden Cont változónak van egy iterátora.
Ezzel érhető el ciklusszerű viselkedés a Slime-ban.
\item \emph{\{\$integer\$\}:} 
Minden Cont változó indexelhető is.
Túlindexelés esetén hibát dob.
A későbbiekben lehetséges lesz hátulról indexelni és tartományt indexelni is.
Utóbbi esetben egy új Cont változó fog létrejönni.
\end{itemize}

Az egyes Cont leszármazottak működését később részletezem.

%----------------------------------------------------------------------------
\subsection{Sablon típusa és alkotóelemei}
\label{sec:STemp}
%----------------------------------------------------------------------------
Egy sablonkezelésre szakosodott nyelvben a legfontosabb, hogy hatékonyan lehessen létrehozni és kezelni sablonokat.

A Slime-ban a sablonokat a Temp(template) típus segítségével kezeljük. Ez felelős minden sablonművelet megvalósításáért.

A legtöbb nyelvben a sablonoknak kétféle komponense van, a szöveg és a mező. (lásd ~\ref{sec:Mustache})
A Slime-ban ez nem elegendő, ugyanis a Slime nem különíti el a kódot és az adatot külön fájlba.
Nem akarjuk azt, hogy az adat tördelése befolyással legyen a kód tördelésére.
Például tegyük fel, hogy van egy többsoros sablonunk egy másik blokkon belül.
Minden sora egy nem whitespace karakterrel kezdődik.
Nem akarjuk a sablon minden sorát a sor legelején kezdeni, inkább pár tabulátorral beljebb szeretnénk igazítani, hogy jól látszódjon, hogy a blokkon belül van.
A sablonokat soronként sem akarjuk kezelni.
Erre a Slime megoldása a speciális karakterek, mint harmadik komponens.

A három komponensnek az alábbi három típus felel meg:
\begin{itemize}
\item \emph{Text:} 
Kezel minden szöveget, így az alárendelt kódrészleteket is.
\item \emph{Slot:} 
Kezeli a sablon mezőit.
Egy template-hez ezek később is hozzáadhatóak.
Egy mezőnek több címkéje is lehet.
A mezők címkéi egyezhetnek is.
Ha a Temp egy mezőjébe szúrnak valamit, akkor a mező nem szűnik meg.
továbbra is elérhető és a beillesztett Temp felülírható.
\item \emph{Spec:} 
Ezzel adhatóak meg speciális karakterek 3-3 kódnévvel.
Jelenleg a Slime 10-féle speciális karaktert kezel:
\begin{itemize}
\item \emph{\textit{$‘\backslash n’$}:} e, ent, enter, 
\item \emph{\textit{$‘\backslash r’$}:} r, ren, renter, 
\item \emph{\textit{$‘\backslash t’$}:} t, tab, tabulator, 
\item \emph{\textit{‘ ’}:} s, spa, space 
\item \emph{\textit{‘.’}:} pe, per, period 
\item \emph{\textit{‘?’}:} qm, qum, question\_ mark 
\item \emph{\textit{‘!’}:} em, exm, exclamation\_ mark 
\item \emph{\textit{‘,’}:} co, com, comma
\item \emph{\textit{‘:’}:} cl, col, colon 
\item \emph{\textit{‘;’}:} sc, sec, semicolon
\end{itemize}
Ez még később ki lesz egészítva a teljes unicode tartományra. Ekkor minden karakter megadható lesz a unicode-ja szerint is, valamint ki lesz egészítve a karakterek legnépszerűbb nyelvekben használt neveivel is.
\end{itemize}

Ezek olyan alapvető típusok, hogy a hatékonyabb deklarációjukat úgynevezett típus zárójelek is segítik. 
Ezek a zárójelek név nélküli példányokat hoznak létre.
A zárójelekre a típusok nevének csupa nagybetűs változatával hivatkozok:

TEXT: \textit{\{"text"\} pl.: \{" This is a text "\}}

SLOT: \textit{\{\$ tags \$\} pl.: \{\$ tag \$\}}

SPEC: \textit{\{@ code @\} pl.: \{@ enter @\}}

Ezeken belül az értékadást egyedi szintaxis is segíti.
Text esetében minden whitespace karakter bent marad a szövegben, ezért a Text zárójelet használjuk szöktetésre is.
Erre mindenképpen szükség van, ha az alárendelt nyelv és a Slime szintaxisában túl sok a közös vonás.
A Slot és Spec zárójelekben minden whitespace karakter figyelmen kívül van hagyva.
A Slot címkéjére és a Spec kódjaira is érvényes a Slime-ban a nevekre vonatkozó formai megkötés (angol betűkből, alulvonásból és számokból állnak, és nem kezdődhetnek számmal).

A Temp típusnak is van típus zárójele. 
Ezen belül a szöveg elemeket nem kell TEXT-be zárni, de lehet, ha szöktetni akarunk. 
A sor végi, eleji és elválasztó karakterek szöktetésre kerülnek. Például:\begin{verbatim}
{| 
		{@e@}{@t@} text {$ slot $} 
		{@e@}{@t@}{"text {$"}
|}
vagy:
{|{@e@}{@t@} text {$ slot $}{@e@}{@t@}{"text {$"}|}
\end{verbatim}Ez egy ilyen sablont eredményez:

\begin{verbatim}
    text {$ slot $}
    text {$ 
\end{verbatim}

Ez ugyan összetettebb, mint más nyelvekben, de a speciális karakterek használata teljesen opcionális.
A TEMP-ek tömörségéről pedig a haladó szintaxis gondoskodik.(lásd ~\ref{sec:SAdvaSyntax})


%----------------------------------------------------------------------------
\subsection{Operátorok és egyszerű eseteik}
\label{sec:SOper}
%----------------------------------------------------------------------------
Ahogy korábban írtam, a Slime négy alapművelettel rendelkezik: deklaráció, törlés, hozzáadás és kiterjesztés. 
Ezeket az alábbi operátorokkal lehet elvégezni:

\begin{itemize}
\item \emph{deklaráció:} 
Jele az "=".
Decl-ként hivatkozunk rá.
DECL-ként hivatkozunk a zárójelre.
Így meg lehet hivatkozni külön a szintaxist és a műveletet is.
A Decl egy új változó létrehozása az adott típussal.
Minden típus példányosítható vele.
DECL-ben a változó neveinek vesszővel való felsorolását egy \textit{':'} és a változó típusa követi. 
A metaadatokat a := választja el a változó értékétől.
Későbbi verziókban a típus paraméter elhagyható lesz, ha egyértelmű a változó értékéből. 
A változó értéke megadható mindig egy azonos típusú változóval.
Tehát értékként megadható típus zárójel:
\begin{itemize}
\item\emph{Text:} \{= text1 : Text := \{"This is a text"\} =\}
\item\emph{Slot:} \{= slot1 : Slot := \{\$ slot1 \$\} =\}
\item\emph{Spec:} \{= spec1 : Spec := \{@ enter @\} =\}
\item\emph{Temp:} \{= temp1 : Temp := \{|This is a template:\{\$slot\$\}|\} =\}
\end{itemize}
Megadható név szerinti meghivatkozás is:
\begin{itemize}
\item\emph{Text:} \{= text2 : Text := text1 =\}
\item\emph{Slot:} \{= slot2 : Slot := slot1 =\}
\item\emph{Spec:} \{= spec2 : Spec := spec1 =\}
\item\emph{Temp:} \{= temp2 : Temp := temp1 =\}
\end{itemize}
Ekkor a változóból nem készül másolat, csak új neveket adunk hozzá.
Másolatot így készíthetünk:
\begin{itemize}
\item\emph{Text:} \{= text1\_ copy : Text := text1.copy =\}
\item\emph{Slot:} \{= slot1\_ copy : Slot := slot1.copy =\}
\item\emph{Spec:} \{= spec1\_ copy : Spec := spec1.copy =\}
\item\emph{Temp:} \{= temp1\_ copy : Temp := temp1.copy =\}
\end{itemize}
Képes más operációk kimenetéből is példányosítani:
\begin{itemize}
\item\emph{deklaráció:} \{= text1 : Text := \{= : Text := \{"This is a text"\} =\} =\}
\item\emph{hozzáadás:} \{= temp : Temp := \{+ … +\} =\}
\item\emph{kiterjesztés:} \{= text1 : Text := \{* … *\} =\}
\end{itemize}
Persze a törlésből nem lehet, mivel annak nincs visszatérési értéke.
\item \emph{törlés:} 
Jele a "X" vagy a "x".
Dele-ként hivatkozunk rá.
DELE-ként hivatkozunk a zárójelre.
A változó elérését kell benne megadni.
Törli egy változónak az egyik nevét, vagy elveszi egy birtokosától.
Egy változó csak akkor szabadul fel, ha az összes nevéről törlik és senki sem birtokolja.
Ha egy változó self attribútumára hívnak törlést, akkor az összes neve szerint törli magát az összes Slime fájlból.
Akkor lehet igazán hasznos, ha nagyon nagy szöveghalmazzal foglalkozunk, vagy le akarunk tiltani ideiglenesen létrehozott neveket.
A törlés többek között történhet név szerint: \textit{\{X name1 X\}} vagy a birtokoson keresztüli elérési út szerint: \textit{\{x birtokos.attribute1 x\}} 
Például az előzőleg deklarált \texttt{text 1} felszabadítható így: \textit{\{X name1 X\}}.
Ha egy \texttt{f1} néven importált fájlban lett létrehozva: \textit{\{X f1.name1 X\}}.
\item \emph{hozzáadás:}
Jele a "+".
Plus-ként hivatkozunk rá.
PLUS-ként hivatkozunk a zárójelre
A hozzáadás egy sokoldalú művelet, ez végez ugyanis minden konkatenációt, beszúrást és deklaráció utáni értékadást.
Lehet vele Slot-ba beszúrni Temp-et, Text, Spec vagy Slot változót: 
\begin{itemize}
\item\emph{Text:} \{+ temp1.slot1 :+ \{"This is a text"\} +\}
\item\emph{Slot:} \{+ temp1.slot1 :+ \{\$ slot1 \$\} +\}
\item\emph{Spec:} \{+ temp1.slot1 :+ \{@ enter @\} +\}
\item\emph{Temp:} \{+ temp1.slot1 :+ \{|This is a template:\{\$slot\$\}|\} +\}
\end{itemize}
Mivel Slot csak Temp-et tárolhat, az utóbbi három esetben a jobb oldali értékek template-be csomagolva kerülnek beszúrásra. 
A Plus ebben alapértelmezetten a bal oldali Temp változót(jelen esetekben temp1) adja vissza.
A Plus-szal lehet egy Temp-et bővíteni Text-tel, Spec-cel, Slot-tal, Temp-pel:
\begin{itemize}
\item\emph{Text:} \{+ temp1 :+ \{"This is a text"\} +\}
\item\emph{Slot:} \{+ temp1 :+ \{\$ slot1 \$\} +\}
\item\emph{Spec:} \{+ temp1 :+ \{@ enter @\} +\}
\item\emph{Temp:} \{+ temp1 :+ \{|This is a template:\{\$slot\$\}|\} +\}
\end{itemize} 
Utóbbi esetben a Temp összetevőit egyesével fűzi a Temp végére. 

Ha \texttt{temp1} eredetileg egy üres Temp volt, akkor a beszúrások után ez lesz belőle:

{|This is a text\{\$ slot1 \$\}\{@ enter @\}This is a template:\{\$slot\$\}|}

Hozzáadás esetén baloldalt csak változó elérési útja állhat.
A beszúrni kívánt oldalt viszont típus zárójel helyett megadhatjuk elérési úttal is.
Lehet bármely művelet kimenete is jobb oldalon.
\item \emph{kiterjesztés:}
jele a '*'.
Exte-ként hivatkozunk rá.
EXTE-ként hivatkozunk a zárójelre
A kiterjesztés a C nyelvek ToString műveletének felel meg. 
Szöveggé alakítja a változókat.
Ugyanakkor az alárendelt nyelv kódjába ágyazva a szöveget be is szúrja az alárendelt kódba. 
Ebből az extra funkcionalitásból származik a neve is.
\begin{itemize}
\item\emph{Text:} Egy másolatot térít vissza.
\item\emph{Slot:} A Slime formátumában adja vissza.
\item\emph{Spec:} A kulcsnak megfelelő karakterré alakítja.
\item\emph{Temp:} Minden elemét sorban kiterjeszti és a szövegeket összekonkatenálja
\end{itemize}
Ezek az értékek is megadhatóak elérési úttal, vagy típus zárójellel vagy egy műveletként, aminek van visszatérési értéke.
\end{itemize}

Természetesen minden operátor zárójel figyelmen kívül hagyja a whitespace karaktereket.

Szintaxis összefoglaló táblázat:
\begin{table}
\begin{center}
  \begin{tabular}{ | l | l | c | c | l |}
    \hline
    \textbf{Művelet}	& \textbf{Jel}	& \textbf{Kódnév}	& \textbf{Zárójel neve}	& \textbf{Belső szintaxis}	\\ \hline
    deklaráció			& = 			& Decl		 		& DECL					& meta adat := érték		\\ \hline
    törlés				& X vagy x		& Dele		 		& DELE					& változó neve				\\ \hline
    hozzáadás			& + 			& Plus		 		& PLUS					& elérés:+érték				\\ \hline
    kiterjesztés		& * 			& Exte		 		& EXTE					& érték						\\
    \hline
  \end{tabular}
\end{center}
\label{table:operBasic}
\caption{operátor formátum és hivatkozás összefoglaló táblázat.}
\end{table}

Ennek a négy műveletnek az összességét Oper-ként hivatkozzuk, a zárójeleiket pedig OPER-ként.

Kommentelni is lehetséges. Erre a \# -es zárójeleket használjuk:

\{\# Ez egy komment, ami nem jelenik meg sehol \#\}

Műveleti zárójelekben szinte bárhol lehet kommentet írni, bármelyik két attribútum és elválasztó jel között.
A Típus zárójelek közül is bármelyikbe a Text kivételével, ami természetesen szökteti a komment zárójelet is.

%----------------------------------------------------------------------------
\subsection{Cont típusok}
\label{sec:SCont}
%----------------------------------------------------------------------------

Alapvető Cont típusok:
\begin{itemize}
\item \emph{Temp:} 
A Temp is Cont típus. 
Iterátorai vannak, content attribútuma és indexelhető.
Ezen kívül a text, slot és spec változói típusonként is lekérhetőek.
Ekkor a második legalapvetőbb Cont típusba, a List-be rendezve adja vissza őket.
\item \emph{List:} 
A List az első a C-ből megszokott tároló osztályokból, ami implementálásra került.
Mint a legtöbb C nyelvben, itt is típusos.
A nyelvben az egymásba ágyazott típusokat kettősponttal tagoljuk, így: List:List:Temp
Ez C++ nyelvekben template-eléssel így néz ki: List<List<Temp> >
A zárójelezés viszont csak akkor praktikus, ha egy típusba egyszerre több típus is ágyazható. 
A Slime jelölése viszont kiegészíthető zárójelezéssel, például ha bevezetjük majd a dictionary-ket Dict néven:

List:Dict:(Text, List:Temp)

Itt azért nem a "kacsacsőr" zárójeleket használjuk, mert azokkal már a kompakt zárójelezést jelöljük. (Lásd fejezet ~\ref{sec:SAdvaSyntax})

Egy List beágyazott típusa Vari is lehet vagy Cont és akkor bármely Cont vagy Vari tárolására képes.

A List használata előnyös gyakran változó hosszú adathalmazok tárolására és mozgatására.
\item \emph{Type:} 
A Type nem más Vari példányok tárolására lett kitalálva, hanem új típusok bevezetésére való, azok metaadatát tárolja.
Ezek a típusok a C struktúráihoz hasonlóan viselkednek.
Függvényeket ugyan nem tartalmazhatnak, de névvel és típussal rendelkező attribútumaik vannak.
Két nem módosítható és azonos hosszú List-et tartalmaz.
Egyik lista tartalmazza az attribútumok neveit (attrs néven).
Itt az attribútumoknak csak egy neve lehet.
A másik lista pedig típusok listáiból áll (types néven).
Azért listáiból, mert így beágyazott típusokkal rendelkező típusokat is tartalmazhat, például olyan List-eket, amik Temp-eket tárolnak.
Ezekbe csak az alapvető négyen túli attribútumai szerepelnek az új típusnak.
Az iterátora párhuzamosan megy végig a két listán név-típuslista párokat adva vissza, List:Vari változókban.
Ezen kívül a Type-nak még egy címkéje van tag néven, ami a típusnevét(pl.: Temp) adja vissza.
Azért nem névként tárolja, mert így nem függ a fájloktól (nem azon a fájlon keresztül érhető el, ami deklarálta a típust).
Ez azért fontos, hogy az alaptípusok, amikor létrejönnek, ne szennyezzék a fájlok namespace-ét.
\item \emph{Inst:} 
Az Inst a Type-pal a programozó által létrehozott típusok példányainak összessége.
Az Inst még absztrakt típusként sem létezik, csak a példányok egységes működését valósítja meg.
Nem példányosítható és nem létezik List:Inst sem.
Minden Inst-nek a Type-pal deklarált típus a típusa.
Egy fix méretű List:Vari-t tartalmaznak.
Ebben tárolják a Vari és Cont ősosztályokon túli attribútumait, vagyis amit Type-ja definiál.
Ezeknek nem kötelező értéket adni, az iterátoruk a nem megadott értékeket egyszerűen átugorja.
Minden attribútuma lekérdezhető a Type-jában definiált név szerint.
\item \emph{File:} 
Slime-ban az importálás File típusú változókkal lett megvalósítva.
Inicializálásuk után ezek tartalmazzák az importált Slime fájl kimenetét és elérhető változóit.
A kimenetük egy Text típusú outp változóban érhető el.
Az aktuális fájlban létrehozott változók is egy File-ban vannak tárolva.
Az aktuális fájl File változója self néven el is érhető.
A \textit{names, self, copy, type, cont, iter, \{\$szám\$\} és outp} változók felülírhatatlanul az aktuális File attribútumait jelentik.
(lásd ~\ref{sec:SVariSuper}, \ref{sec:SContSuper})
Éppen ezért, bár az előbbi nevekkel változókat lehet deklarálni, elérhetetlenek lesznek ezeken (a már a File által foglalt) neveken. 
Viszont az aktuális File összes attribútuma a létrehozott változók kivételével nem törölhető.
Ezért a fenttartott (korábbi felsorolásban szereplő) neveken törölve legalább az azokkal a nevekkel a fájlból létrehozott változók törölhetőek.
\end{itemize}


%----------------------------------------------------------------------------
\subsection{Cont típusok Decl művelete}
\label{sec:SContDecl}
%----------------------------------------------------------------------------
Mivel a nyitó és csukó zárójelek használata körülményes, ezért elég korán be lettek vezetve a több műveletes zárójelek.
Ez annyit tesz, hogy minden típus és operátor zárójelben többször is el lehet végezni a típusának megfelelő műveletet.
Ekkor a műveleteket pontosvesszővel választjuk el.
Ez a jelölés is a C alapú nyelvekből származik.
Ekkor a visszatérési értékkel rendelkező zárójelek List típusú visszatérési értéket adnak.
Ha a műveletek visszatérési értéke más típusú, akkor ez egy List:Vari. 
Sok nyelvben megoldották már a pontosvesszők elhagyását, ilyenkor mindig a sortörés karaktereket használták fel.
A Slime esetében ez több helyen is problémás lett volna, például a sablonoknál sem akarjuk a több soros sablonokat mindig egy sorban megadni
(Későbbiekben persze egyes műveleteknél ki lehet majd váltani a pontosvesszőt sortöréssel)

Cont változókat éppen ezért lehet a beágyazott típusnak megfelelő típus zárójellel is deklarálni:

\{= specL1 : List:Spec := \{@ e;t @\} =\}

Ugyanakkor mindig megadhatóak egyszerűen az elemeik felsorolásával is:

\{= specL1 : List:Spec := \{@ e @\}, \{@ t @\} =\}

vagy pl.:

\{= temp1 : Temp := \{@ e @\}, \{@ t @\} =\}

Minden Vari deklarálható az elérési útjával is, amit nevek és indexek ponttal tagolt sorozatával adhatunk meg.
Erre az elérési utat path-ként hivatkozom.
Például az inst1 nevű Inst attr3 nevű List típusú attribútumának a harmadik eleméhez vezető path: inst1.attr3.2 
(mivel a lista első elemének 0 az indexe)

A Type alapvetően név$--$típus párokkal adható meg:

\{= tempi : Type := te1 : Text, te2 : Text, 

sp1 : Spec, sp2 : Spec, sl1 : Slot, sl2 : Slot=\}

Ugyanakkor azonos típust attribútumoknál elég a típust egyszer jelölni:

\{= tempi : Type := te1, te2 : Text, sp1, sp2 : Spec, sl1, sl2 : Slot =\}

Megadható ugyan a nevek és típus listák két listájával is:

\{= tempi : Type := \{= :List:Name := te1, te2, ... =\}, 

\{= :List:List:Type := \{= :List:Type := Text =\}, \{= :List:Type := Text =\}, .... =\} =\}

(Az utóbbi azért listák listája, hogy a beágyazott típusokat, mint \textit{List:Temp} esetében a \textit{Temp}, is kezelni tudja)  

és a név$--$típus párok mint listák listájaként:

\{= tempi : Type := \{= :List:Vari := te1, \{= List:Type := Text =\} =\}, 

\{= :List:List:Type := te2, \{= List:Type := Text =\} =\} ... =\}

De ezeket (egyértelmű okokból) nem használjuk, csak az egységesség okán kerültek implementálásra.
Ha a típusok egyértelmű esetekben elhagyhatóak lesznek, akkor jelentősen tömörebbek lesznek ezek a formátumok is.
Elvégre rengeteg kódolást lehet majd spórolni a \textit{:List:Name, List:Type, :List:Vari} részek elhagyásával.

Az Inst-eknél definiálhatjuk, hogy melyik attribútumoknak adunk értéket:

\{= t1 : tempi := te1 := \{”text”\}, sl3:=\{\$slotty\$\}, sp2:=\{@e@\} =\}

de erre sem vagyunk kötelesek, ha az értékeket sorrendben adjuk meg:

\{= t1 : tempi := \{”text”\}, \{”text”\}, \{”text”\}, 

\{@e@\}, \{@e@\}, \{@e@\}, \{\$slotty\$\}, \{\$slotty\$\} =\}

Nem vagyunk kötelesek minden attribútumnak értéket adni.
Ha egyes attribútumtípusokból az utolsóknak nem kívánunk értéket adni, akkor az a későbbi verziókban kihagyható lesz.

A File egy text-tel hozható létre, ami a futtató gépen az elérési útvonalát tartalmazza:

\{= f1 :File := {"/home/boss/Documents/test\_complex\_long"\} =\}

Ekkor a file le is fut és a generált kimenetet is fogja tartalmazni az outp változója.
A létrehozott változóiból viszont csak a nem törölt változói lesznek elérhetőek.



%----------------------------------------------------------------------------
\subsection{Cont típusok Plus művelete}
\label{sec:SContPlus}
%----------------------------------------------------------------------------
\begin{itemize}
\item \emph{Lehet vele listához elemet hozzáadni:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= list1 : List:Temp := \{|ez egy Temp|\}=\}
\item \{= temp1 : Temp := \{|ez egy másik Temp|\}=\}
\end{itemize}
\item \emph{művelet:}
\{+ list1 :+ temp1 +\}
\item \emph{kimenet:}
List: \{|ez egy Temp|\}, \{|ez egy másik Temp|\}
\item \emph{magyarázat:}
Az új elemet a lista végére fűzte. 
A visszatérési érték maga a lista.
\end{itemize}

\item \emph{Lehet vele listába adott indexen elemet szúrni:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= list1 : List:Temp := \{|ez egy Temp|\}, \{|ez is egy Temp|\}=\}
\item \{= temp1 : Temp := \{|ez egy másik Temp|\}=\}
\end{itemize}
\item \emph{művelet:}
\{+ list1.1 :+ temp1 +\}
\item \emph{kimenet:}
List: \{|ez egy Temp|\}, \{|ez is egy Temp|\}, \{|ez egy másik Temp|\}
\item \emph{magyarázat:}
A temp1 második eleme lesz a listának.
A második elem nem cserélődik le, csak eltolódik.
A visszatérés maga a most már három elemű lista.
\end{itemize}

\item \emph{Lehet vele Inst attribútumának értéket adni:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= type1 : Type  := attr1:Temp =\}
\item \{= inst1 : type1 := \{|lol|\}=\}
\item \{= temp1 : Temp  := \{|ez egy Temp|\}=\}
\end{itemize}
\item \emph{művelet:}
\{+ inst1.attr1 :+ vari1 +\} 
\item \emph{kimenet:}
type1 példány: attr1=\{|ez egy Temp|\}
\item \emph{magyarázat:}
Az inst1 attr1 nevű attribútumának adtuk értékül a temp1 változót.
Mivel a type1-ben megadott meta adat szerint ez egy Temp, az értékül adás sikeres volt.
A kimenetünk az intst1, ekkor már a temp1-gyel az attr1 attribútumában.
\end{itemize}

\item \emph{Egy Temp Slot-jába List:Temp-et szúrva a lista minden elemére elvégzi a beszúrást:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= temp1 : Temp  := \{|ez egy Temp\{\$slot1\$\}|\}=\}
\item \{= temp2 : Temp  := \{|ez egy másik Temp1|\}=\}
\item \{= temp3 : Temp  := \{|ez egy másik Temp2|\}=\}
\item \{= temp4 : Temp  := \{|ez egy másik Temp3|\}=\}
\end{itemize}
\item \emph{művelet:}
\{+ temp1.slot1 :+ \{= :List:Temp :+ temp2, temp3, temp4 =\} +\} 
\item \emph{kimenet:}
List: \{|ez egy Tempez egy másik Temp1|\}, \{|ez egy Tempez egy másik Temp2|\}, \{|ez egy Tempez egy másik Temp3|\}
\item \emph{magyarázat:}
Tehát itt a temp1 ből három másolatot készít, mert a beszúrt lista is három elemű.
Az első másolat slot1-ébe beszúrja a temp2 Temp-et; a másodikba a temp3-at és a negyedikbe a temp4-et.
Ezt követően a három másolatot egy listában téríti vissza.
\end{itemize}

\item \emph{ Egy Cont változót egy másikhoz adva a hozzáadást végezhetjük az elemek között is:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= temp1 : Temp  := \{|\{\$slot1\$\}\{\$slot2\$\}\{\$slot3\$\}|\}=\}
\item \{= temp2 : Temp  := \{|ez egy másik Temp1|\}=\}
\item \{= temp3 : Temp  := \{|ez egy másik Temp2|\}=\}
\item \{= temp4 : Temp  := \{|ez egy másik Temp3|\}=\}
\end{itemize}
\item \emph{művelet:}
\{+ temp1 :+ \{= :List:Temp :+ temp2, temp3, temp4 =\}

: slot1 :+ 2 , slot2 :+ 1, slot3 :+ 0   +\} 
\item \emph{kimenet:}
Temp: {|ez egy másik Temp1ez egy másik Temp2ez egy másik Temp3|}
\item \emph{magyarázat:}
Itt az elemeket páronként megadjuk.
Mint később látható lesz, ez nem mindig szükséges.
A Temp is Cont, így az is lehet a bal és jobb oldali változók egyike.
\end{itemize}

\item \emph{ Egy Cont változóhoz egy másikat adva az előbbihez hozzáfűzi az utóbbi elemeit:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= list1 : List:Temp  := \{|temp1:\{\$slot1\$\}|\}, \{|temp2:\{\$slot1\$\}|\}, \{|temp3:\{\$slot1\$\}|\}=\}
\item \{= list2 : List:Temp  := \{|text of temp4|\}, \{|text of temp5|\}, \{|text of temp6|\}=\}
\end{itemize}
\item \emph{művelet:}
\{+ list1 :+ list2 +\}
\item \emph{kimenet:}
List: \{|temp1:\{\$slot1\$\}|\}, \{|temp2:\{\$slot1\$\}|\}, \{|temp3:\{\$slot1\$\}|\}, \{|text of temp4|\}, \{|text of temp5|\}, \{|text of temp6|\}
\item \emph{magyarázat:}
A list2 elemeit egyszerűen a list1 végéhez fűzi és visszatéríti a list1-et.
A Temp-be lista szúrás és Temp-be Inst szúrás kivételek ez a mechanika alól.
\end{itemize}

\item \emph{Cont változóhoz egy másik iterátorát adva az előbbihez hozzáadja az utóbbi elemeit:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= list1 : List:Temp  := \{|temp1:\{\$slot1\$\}|\}, \{|temp2:\{\$slot1\$\}|\}, \{|temp3:\{\$slot1\$\}|\}=\}
\item \{= list2 : List:List:Temp  := 

		\{= : List:Temp :=\{|text of temp4|\}, \{|text of temp5|\}=\},
		
	 	\{= : List:Temp := \{|text of temp6|\}, \{|text of temp7|\}=\}
	 	
	 	=\}
\end{itemize}
\item \emph{műveletek:}
\{+ list1 :+ list2.iter +\}
\item \emph{kimenet:}
List: \{|temp1:\{\$slot1\$\}|\}, \{|temp2:\{\$slot1\$\}|\}, \{|temp3:\{\$slot1\$\}|\}, \{|text of temp4|\}, \{|text of temp5|\}, \{|text of temp6|\}, \{|text of temp7|\}
\item \emph{magyarázat:}
Jól látható a különbség az előző esethez képest.
Ha list2 Temp-ekből állna, akkor a működés nem különbözne semmiben az előzőtől.
Így viszont, hogy a list2 listák listája, a listákon végig iterálva tudjuk azok tartalmát a list1 végéhez fűzni.
A kimenet a list1.
\end{itemize}

\item \emph{ Egy Cont változó iterátorához egy másikét adva az előbbi minden eleméhez hozzáadnja az utóbbi azonos indexű elemét:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= list1 : List:Temp  := \{|temp1:\{\$slot1\$\}|\}, \{|temp2:\{\$slot1\$\}|\}, \{|temp3:\{\$slot1\$\}|\}=\}
\item \{= list2 : List:Temp  := \{|text of temp4|\}, \{|text of temp5|\}, \{|text of temp6|\}=\}
\end{itemize}
\item \emph{művelet:}
\{+ list1.iter :+ list2.iter +\}
\item \emph{kimenet:}
List: \{|temp1:text of temp4|\}, \{|temp2:text of temp5|\}, \{|temp3:text of temp6|\}
\item \emph{magyarázat:}
Ha a két lista egyike rövidebb lenne, akkor a két lista hosszai közül a kisebb darab beszúrás történne.
Jelen esetben mindkét lista három hosszú, ezért történik három beszúrás.
A list1 első elemébe a list2 első eleme szúródik és így tovább.
A kimenet a list1.
\end{itemize}

\item \emph{ Egy Cont változó iterátorához egy másik Contot adva az előbbi minden eleméhez hozzáadja az utóbbit:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= list1 : List:Temp  := \{|text of temp1|\}, \{|text of temp2|\}=\}
\item \{= list2 : List:Temp  := \{|text of temp3|\}, \{|text of temp4|\}=\}
\end{itemize}
\item \emph{művelet:}
\{+ list1.iter :+ list2 +\}
\item \emph{kimenet:}
List: List: \{|text of temp1text of temp3|\}, \{|text of temp1text of temp4|\}, List: \{|text of temp2text of temp3|\}, \{|text of temp2text of temp4|\}
\item \emph{magyarázat:}
Először a list1 első elemébe szúródik be a list2, majd a másodikba.
Mivel mindkét esetben listát adunk hozzá Temp-hez, két listánk keletkezik.
A kimenet a két lista egy listába rendezve.
\end{itemize}

\item \emph{ Lehetséges Cont változóhoz adott indexen is hozzáadni a másik elemeit:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= list1 : List:Temp  := \{|text of temp1|\}, \{|text of temp2|\}=\}
\item \{= list2 : List:Temp  := \{|text of temp3|\}, \{|text of temp4|\}=\}
\end{itemize}
\item \emph{művelet:}
\{+ list1.1 :+ list2 +\}
\item \emph{kimenet:}
List: \{|text of temp1|\}, \{|text of temp3|\}, \{|text of temp4|\}, \{|text of temp2|\}
\item \emph{magyarázat:}
A list2 elemei a list1-be az 1-es indextől, tehát a második helytől kezdve kerülnek beszúrásra.
Ezért a kimenetben az első helyen a list1 első eleme áll, a második és harmadik helyen a list2 elemei sorban és végezetül a list1 második eleme.
A kimenet a list1.
\end{itemize}

\item \emph{ Egy Temp-be beszúrhatunk egy Inst-et így:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= type1 : Type  := at1, at2 : Temp=\}
\item \{= inst1 : type1  := {|ez egy Temp|}, {|ez is egy Temp|}=\}
\item \{= temp1 : List:Temp  := \{|\{\$sl1\$\}\{\$sl2\$\}|\}=\}
\end{itemize}
\item \emph{művelet:}
\{+ temp1 :+ inst1 : sl1 :+ at1 , sl2 :+ at2+\}
\item \emph{kimenet:}
Temp: \{|ez egy Tempez is egy Temp|\}
\item \emph{magyarázat:}
Ekkor megadtuk, hogy a temp1 melyik Slot-jába szúrjuk bele az inst1 melyik attribútumát.
A visszatérési érték a temp1.
\end{itemize}

\item \emph{Ha az Inst megfelelő attribútumainak ugyanaz a neve, mint a Temp megfelelú Slot-jainak, akkor az előző művelet egyszerűbben is elvégezhető:}
\begin{itemize}
\item \emph{változók:}
\begin{itemize}
\item \{= type1 : Type  := sl1, sl2 : Temp=\}
\item \{= inst1 : type1  := {|ez egy Temp|}, {|ez is egy Temp|}=\}
\item \{= temp1 : List:Temp  := \{|\{\$sl1\$\}\{\$sl2\$\}|\}=\}
\end{itemize}
\item \emph{művelet:}
\{+ temp1 :+ inst1 +\}
\item \emph{kimenet:}
Temp: \{|ez egy Tempez is egy Temp|\}
\item \emph{magyarázat:}
Mivel az inst1 attribútumainak azonos neve van, mint a temp1 Slot-jainak, a fordító kitalálja magától a párosításokat.
A visszatérési érték a temp1.
\end{itemize}

\end{itemize}
 
Ezek a műveletek teszik a Cont leszármazottakat igazán hasznossá.
Ha az adatainkat megfelelő attribútumnevekkel rendelkező Inst-ek List-jében tárolom,
akkor abból egy sorban legenerálható az összes kimeneti adat:

\{= list2 : List:Temp := \{+ temp1 :+ list1.iter +\} =\}

Ez a list1 elemeit egyesével fogja hozzáadni a temp1-hez.
Mivel a list1 elemei Inst-ek a megfelelő adatokkal, minden beszúrás a megfelelő mezőkön fog történni.
A kimenetet képző kód pedig listaként el lesz tárolva list2-ben.

%----------------------------------------------------------------------------
\subsection{Cont típusok és az Exte művelet}
\label{sec:SContExte}
%----------------------------------------------------------------------------
Exte zárójelben a kiírni kívánt elemeket pontosvesszővel elválaszva soroljuk.
Ha közvetlen az alárendelt kódba van ágyazva, akkor az Exte a kimeneteit egymás után fogja kiírni elválasztás nélkül:

\{* variable1; variable2*\} \{\# returns it as list of text\#\}

A Cont változók kiiratásánál adható meg elválasztó szöveg.
Ez lehet speciális karakterek sorozata vagy Temp:

\{* list1 : \{@ e;e;e@ \} *\} \{\# You can add divider character by special character \#  \}

\{* list1 : \{|This is a temp, witch can include special character too. Like \{@ e@ \} for example|\} *\} \{\# or template\# \}

Azért nem lehet szöveg, mert az Temp-ként is könnyen megadható, de a Temp-pel ellentétben nem tartalmazhat speciális karaktereket.
Lésőbb a Text-ees verzió is bevezetésre fog kerülni.

Ha egy Cont változó tartalmaz egy másikat, akkor az utóbbi elemeit is ugyanazzal az elválasztó szöveggel fogja kiírni. 

%----------------------------------------------------------------------------
\subsection{A Refe típus}
\label{sec:SRefe}
%----------------------------------------------------------------------------

A szakdolgozatkiírás egyik legfontosabb pontja az volt, hogy lehessen az IRTG-k bemenetét RegEx kifejezésekkel megadni.
Az volt az elképzelés, hogy ekkor minden arra illeszkedő nem terminális szimbólummal elérhető lesz az átírási szabály.
Ennek a funkcionalitásnak a megvalósítása a Refe.

A Refe érdekessége, hogy félúton van egy Vari és egy Oper között.
Egy Cont változóként viselkedik, de nem tárolja el az elemeit.
Egy típus (typeRest nevű attribútum) megkötésből és egy RegEx (regex nevű attribútum) mintából áll.
Deklarációnál is ezt kell megadni vesszővel elválasztva.
Ez a két attribútum csak név szerint érhető el.
Nem képzik részét a Refe cont-jának és az iterátor sem érinti őket.
Amikor az elemeit meghivatkozzuk, akkor kikeresi az adott típusú változókból azokat, melyek path-ja illeszkedik a RegEx-re.
Ezeket egy listában adja vissza legtöbbször.

Operátor, mivel a változókat mindig újra összegyűjti és vissza is téríti listában.

Van típus zárójele:

REFE: \{\& Type :\& t[123] \&\}

A REFE-ben minden whitespace karakter szöktetésre kerül.
A REFE-ben sem lehet egyszerre több műveletet végezni jelenleg, bár ez a későbbiekben változni fog.
A REFE alapértelmezetten a kikeresett elemeket téríti vissza.
Ha viszont egy Refe típusú Vari-nak adjuk értékként, akkor az felismeri, hogy referenciáról van szó.

\{= refe1 : Refe := \{\& Spec :\& $\land$ spec[123]\$\&\} =\}

Visszatérési értékéből lista is példányosítható:

\{= specL1 : List:Spec := \{\&Spec :\& $\land$ spec[123]\$\&\} =\}

és minden, ami listával inicializálható:

\{= temp1 : Temp := \{\&Spec :\& $\land$ spec[123]\$\&\} =\}

\{= inst1 : Type1 := \{\&Spec :\& $\land$ spec[123]\$\&\} =\}

Mindig abból a fájlból kiindulva fog keresni, ahonnan létrehozták.
Így egy importált fájl változóira a fájlban létrehozott referencia a fájlon kkívülről is helyesen fog működni.
Segítségével a változók csoportosíthatóak, és a csoportok változnak is új változók létrehozása és régiek törlése esetén.
Ha például IRTG szabályokat tárolunk Temp-ekben, amiknek a nevébe kódoljuk a típusukat (NNrule1, NNrule2 ...),
akkor azok egy Refe-vel meghivatkozhatóak:

\{\& Temp :\& NNrule[0-9]+ \&\}

Ha még csak az NNrule-oknak alapul szolgáló Temp létezik NNruleBase néven, 
és az abba beszúrandó adatok  NNdataBase típusú Inst-ekben (NNdata1, NNdata2 ...),
akkor a Tempek elkészítése és listába mentése is tömören elvégezhető:

\{= NNrules : List:Temp := 

\{+ NNruleBase +: 

\{= :Iter:NNdataBase := 

\{\# Összegyűjti az NNdataBase típusú Inst-eket, amiknek a neve illeszkedik a \textit{NNdata[0-9]+} regexre egy List:NNdataBase-be.\#\}

\{\& NNdataBase :\& NNdata[0-9]+ \&\} 

=\} \{\#A listának elkészíti a Iter:NNdataBase típusú iterátorát\#\}

+\} \{\#Az iterátort hozzá adja a NNruleBase Temp-hez\#\}

=\} \{\#A hozzáadásból keletkező listához egy nevet csatol\#\}

A Refe segítségével a törlés is egyszerűbb:

\{x temp1 ; specL1; \{\& NNdataBase :\& NNdata[0-9]+ \&\} x\}

Ekkor a törlés minden név szerint megtörténik.



%----------------------------------------------------------------------------
\subsection{Haladó szintaxis}
\label{sec:SAdvaSyntax}
%----------------------------------------------------------------------------
A zárójelezés jelentős áldozatokat jelent a programozás hatékonyságának terén. 
Nagyon problémás minden műveletnél egy nyitó és egy csukó zárójelet is kitenni, ezért két lehetőség is van tömörítésre.

Az első lehetőség az egysoros és kompakt zárójelek használata. 
Az egysoros zárójelek a sor végéig tartanak, a kompakt zárójelek pedig az első whitespace karakterig. 
Így ezek végén nem kell a csukó zárójelet kitenni. 
Az egy soros zárójeleket kapcsos helyett szögletes zárójellel jelöljük, a kompakt zárójeleket pedig kacsacsőr zárójellel. 
Így például a deklaráció \{= … =\} zárójelének az egysoros párja a [= … és a kompakt pedig a <=… zárójelek.
A kompakt zárójelek jelölésére sokkal alkalmasabb a kerek zárójelnél a kacsacsőr.
Könnyebb észrevenni az alárendelt kódrészletekben.
Éppen ezért jelöli ez a kompakt zátójelet és a kerek a beágyazott típusok csoportjait.

(Ismétlés a ~\ref{sec:SCont} fejezetből)
A második megoldás az, hogy egy zárójelben többet is végezhetünk az annak megfelelő műveletből. 
Ekkor a műveleteket pontosvesszővel választjuk el.
Ez a jelölés is a C alapú nyelvekből származik.
Ekkor a visszatérési értékkel rendelkező zárójelek List típusú visszatérési értéket adnak.
Ha a műveletek visszatérési értéke más típusú, akkor ez egy List:Vari. 
Sok nyelvben megoldották már a pontosvesszők elhagyását, ilyenkor mindig a sortörés karaktereket használták fel.
A Slime esetében ez több helyen is problémás lett volna, például a sablonoknál sem akarjuk a több soros sablonokat mindig egy sorban megadni
(A későbbiekben persze egyes műveleteknél ki lehet majd váltani a pontosvesszőt sortöréssel.)

A nyelvben létező műveleteket a következőképpen jelöljük:
\begin{table}
\begin{center}
  \begin{tabular}{ | l | c | c | l | l | }
    \hline
    név		& kódnév 	& blokkos 		& egysoros 	& kompakt	\\ \hline
    komment		& COMM 		& \{\# …\#\} 	& [\# … 	& <\# … 	\\ \hline
    szöveg 		& TEXT 		& \{" …"\} 		& [" … 		& <" … 		\\ \hline
    speciális	& SPEC 		& \{@ …@\} 		& [@ … 		& <@ … 		\\ \hline
    mező 		& SLOT 		& \{\$ …\$\} 	& [\$ … 	& <\$ … 	\\ \hline
    sablon 		& TEMP 		& \{| …|\} 		& [| … 		& <| … 		\\ \hline
    referencia	& REFE 		& \{\& …\&\} 	& [\& … 	& <\& … 	\\ \hline 
    deklaráció 	& DECL 		& \{= …=\} 		& [= … 		& <= … 		\\ \hline
    törlés 		& DELE 		& \{x …x\} 		& [x … 		& <x … 		\\ \hline
    hozzáadás	& PLUS 		& \{+ …+\} 		& [+ … 		& <+ … 		\\ \hline
    kiterjesztés& EXTE 		& \{* …*\} 		& [* … 		& <* … 		\\
    \hline
  \end{tabular} 
\end{center}
\label{table:brackets}
\caption{Az összes zárójel az összes módban azok nevével és kódnevével}
\end{table}
	 	 	
Érdekesség:
A Slime nyelv neve onnan ered, hogy a műveletek blokkos jelölése a fantasy irodalom slime fajának példányaira emlékeztetnek.
Ekkor a művelettípust jelölő karakterek a lény szemei. 
Az egysoros zárójelekre half slime, a kompaktra pedig slime eye-ként is szoktunk hivatkozni szlengesen.

Azt is jó kihasználni, hogy mindig csak az aktuális zárójel szintaxisa érvényesül.
Az egymásba ágyazott zárójeleknél a beágyazottak szintaxisa semmiben sem függ a befoglaló zárójel szintaxisától. 
Így egy kompakt zárójelbe ágyazott egysoros zárójelet továbbra is csak az első sortörés zárja, ahogy a blokkosat is csak a csukó zárójel. 
Az egysoros zárójel annyi whitespace-t tartalmaz, ami nem sortörés, amennyit csak szeretne, ahogy a blokkos is akármilyen whitespace-t. 
Ez persze az egysoros zárójelbe ágyazott blokkos zárójelre is teljesül. 
Például ez egy Temp-et hoz létre három Spec-ből: <|[@ enter; enter; tabulator

A TEMP nem ér véget az első pár whitespace karakternél, mert az az egysoros SPEC része.
Ehelyett mindkettőt a sor végi sortörés zárja.

A whitespace-ek kezelése másban is eltérhet zárójeltípusonként, például az egysoros és kompakt zárójeleknek legtöbbször nem része az őket záró whitespace. 
Ezért zár több egymásba ágyazott egysoros zárójelet is a sort záró sortörés. 
A kompakt Spec és Slot zárójeleknek viszont része az őket záró whitespace. 
Általánosságban a zárójelek minden belső whitespace karaktert figyelmen kívül hagynak. 
Az alárendelt nyelvbe ágyazott minden speciális zárójel előtti whitespace is kimarad a kimenetből. 
Text zárójelben minden whitespace megmarad. 
Temp esetében a sortörő, sor végi és sor eleji whitespace-k maradnak csak ki. 
Temp-ben ezen kívül nincs minden szöveg Text zárójelben. 
A legtöbb a beágyazott zárójeleken kívül helyezkedik el. 
Éppen ezért van szükség kompakt Slot és Spec esetén, arra hogy a záró whitespace ne a környezet része legyen, különben a kompakt zárójelek nagyon beleolvadnának a sablonokba.



%----------------------------------------------------------------------------
\subsection{Nevek}
\label{sec:SName}
%----------------------------------------------------------------------------
A változók nevei a Name nevű változóval manipulálhatóak, de ez a típus a következő verzióban már nem fog szerepelni.
Lényegében egy Text.
A típuskülönbség csak a fordítót segíti abban, hogy mikor kívánunk névmanipulációt végezni.
Például, ha egy Temp-be egy List:Text-et szúrunk, akkor az alapjáraton a végéhez konkatenálódik.
Onnan tudja a fordító, hogy új neveket akarunk valójában a Temp-hez adni, hogy List:Name típusú, nem List:Text.

Deklarálni ugyanazokon a módokon lehet:

\{= n : Name := \{"Name"\} =\}

vagy

\{= n : Name := Name =\}

Lista viszont készíthető belőle így is:

\{= nList : List:Name := name1, name2, name3 =\}

Egy Vari-hoz hozzáadhatóak a nevek egyesével is meg listával is:

\{+ vari += n +\}

\{+ vari += nList +\}

Mindkét esetben a nevek fel is regisztrálódnak az aktuális fájlba, amiből hozzá lettek adva a változóhoz.

%----------------------------------------------------------------------------
\section{Implementáció}
\label{sec:SImplementation}
%----------------------------------------------------------------------------
A fordító jelenlegi implementációja \texttt{Kotlin}-ban\footnote{\url{https://kotlinlang.org}} készült.
A Kotlin Java-ra fordul és JVM-en fut.
Szintaxisa leginkább a Scala nyelvén alapszik, de sok hasznos megoldást gyűjtött össze más nyelvekből is.
Sok újítást is behozott, az egyik legfontosabb a null safety: a változók értéke nem lehet null, csak ha azt a típusban '?'-lel jelöljük (pl.: String?).
Az ilyen változókat nullable-nek is hívjuk.
Ezzel biztosítja, hogy ne érhesse a programozót váratlan nullpointer exception.
Ehhez hasonlóan a tárolók tartalma alapértelmezetten nem módosítható.
Ugyanakkor minden tárolónak van egy mutable verziója is, ami már szabadon módosítható, így nem tűnhet el adat anélkül, hogy számolnánk vele.
Kotlinban nem kell pontosvesszőket raknunk.
Kotlinban az egyszerű osztályokat egyetlen sorban is megírhatjuk és legtöbbször meg se kell adnunk az új változók típusát, mert azokra a fordító magától is képes rájönni.
Mára már az egész Android platform átállt Kotlinra.
Arról is hallani híreket, hogy hamarosan elhagyja a JVM-et, ettől a lépéstől jelentős teljesítményjavulás várható.

A Slime implementáció \texttt{ANTLR}-t (ANother Tool for Language Recognition)\footnote{\url{https://www.antlr.org}} használ a parszoláshoz.
Ez egy robosztus könyvtár fordítók implementálásához, ami sok nyelven képes kódot generálni. 
Az ANTLR a szintaktikai elemzés során feltokenezi a szöveget és szintaktikai fát épít. 
A tokenezéshez szüksége van egy \texttt{lexer grammar}-re (SlimeLexer.g4), és a fa felépítéséhez egy \texttt{parser grammar}-re (SlimeParser.g4). 
Ezek tartalmazzák a nyelv nyelvtanának átírási szabályait és a tokenezéshez szükséges RegEx-szerű, de annál fejlettebb mintákat. 
Az ANTLR ezekből a nyelvtanokból osztályokat generál. 
Sok nyelvben képes erre, de Kotlinban még nem, így Java osztályokat generáltatunk vele. 
Ezek az osztályok végzik a tokenezést (SlimeLexer) és a parszolást (SlimeParser). 
Ezen kívül olyan osztályokat is generál, amik alapul szolgálnak a  szemantika megvalósításához. 
Ehhez a fa bejárásának két módja a listeneres (SlimeParserBaseListener) és visitoros SlimeParserBaseVisitor).
Én a visitoros bejárást választottam, ennek az a lényege, hogy van egy Visitor osztályunk, ami a parseTree összes csúcsát meg tudja különböztetni Visitor Pattern segítségével.
Ezután az egyes csúcsokat a visit függvények fordítják műveletekre.

A \texttt{lexer} nyelvtan \texttt{fragment}-ekből és \texttt{lexer rule}-okból áll. 
A \texttt{fragment}-ek önmagukban nem azonosítanak tokent, de részei lehetnek lexer szabályoknak. 
Többek között arra jók, hogy tömörebben írhassunk le hasonló szabályokat, vagy olyan szabályokat, amikben sok az ismétlés. 
Ehhez viszont nem mindig nyújtanak hatékony megoldást.

A lexer szabályok azonosítják a tokeneket
A Slime esetén a tokeneket az alárendelt nyelv kódrészei, a nyitó és csukó zárójelek, elválasztó karakterek és változónevek teszik ki.

A \texttt{lexer} képes váltogatni módok között, amikben más lexer szabályok lesznek érvényesek. 
A módokat verem módjára kezeli az ANTLR. 
Megadható, hogy mely tokenek esetén menjen be egy adott módba és az is, hogy annak a módnak mely tokenjei esetén térjen vissza. 
Például ilyen, hogy “\{|” esetén belépünk a Temp belsejében érvényes szintaxis lexer módjába és “|\}” esetén pedig visszatérünk. 
A parser és lexer nyelvtan össze is vonható, de vegyes nyelvtanban nem lehet a lexernek több módja.
Így a Slime nem lett volna megvalósítható.
Nagy gyengesége a nyelvnek, hogy nem tartozhatnak a szabályok több módhoz is. 
Így a Slot nyitó zárójelét is hét különböző token kezeli attól függően, hogy melyik módból akarjuk elérni. 
Ugyanakkor a \texttt{fragment}ek  minden mode alatt elérhetőek. 
Használjuk is őket, de nem jelent tömörítést, ha a “\{|” zárójelet egy minimum két karakteres nevű \texttt{fragment}-be csomagoljuk.
Minden speciális zárójelnek külön módja van, kivéve a 4 operátor zárójelnek (OPER) és a SLOT-SPEC párosának (SLSP). 
Ezen kívül minden módnak be kellett vezetni egy egysoros és kompakt változatát is, mert másképp nem megoldható a whitespace-ek egyedi kezelése.

Erre is jó megoldást nyújt a Slime. 
Van a kódban 27 nem üres sor a nyitó zárójelek kezelésére, ami négyszer is előfordul.
Előfordulásonként a szabályok nevének pár karaktere tér el, és önmagában is sok ismétlést tartalmaz. 
Ennek karbantartása már template-eléssel nem jelentene problémát. 
Sőt template-eléssel a fragmentek is teljes mértékben kiválthatóak.

A parser szabályok már a lexer és más parser szabályokból építkeznek. 
Ezek feladata felismerni az egyes műveleteket és beazonosítani az attribútumokat. 
Az egységesség céljából minden művelet parser szabálya \texttt{head}, \texttt{body} és \texttt{tail} részből áll.
Ebből a head és a tail csak a nyitó és csukó zárójelek, és csukó whitespace-ek. 
Az összetettebb zárójeleknél, mint Decl, Exte vagy Plus, a body további bodyPart-okra van bontva. 
Az ANTLR minden parser szabályra generál egy leszármazottat az elemzési fája csúcsából. 
Ezekre az osztályokra tartalmaz a visitor osztály visit függvényeket. 
A Slime esetében ez a visitor alap a SlimeParserBaseVisitor.
A belőle származtatott osztályom, a MySlimeParserVisitor valósítja meg a fordító legfőbb funkcionalitását. 
Minden zárójel parszer szabályának a body-ja állítja elő a valódi kimenetet.
A zárójel visit függvénye csak továbbítja a hozzá tartozó body visit függvényének kimenetét. 
Összetettebb esetekben a body is csak a bodyPart-ok végeredményének az összegzését végzi. 
Ez a kimenet pedig mindig valamilyen, a Slime-ban létező típussal rendelkezik.

A fordító a parancsok végrehajtási sorrendjét nem optimalizálja.
Szekvenciálisan hajtja végre azokat végig látogatva mindet, egyesével.

A Slime típusainak mind létezik a háttérben megfelelő osztály, ami S{$ typeName $} módra van elnevezve. 
Mindegyik az SVari absztrakt ősosztályból származik.
Az SVari tartalmazza a változó neveit és a Slime-beli típusának a nevét.
Biztosítja, hogy a változó elérhető legyen a nevein keresztül.
Minden változónak lekérhetőek a nevei (names), önmaga (self), a névtelen másolata (copy) és típusa (type).
Az SVari az alap működéshez szükséges függvények absztraktjait is tartalmazza. 
\begin{itemize}
\item \emph{listPaths:} Kilistázza az adott változóból elérhető összes változó onnan viszonyított útját.
\item \emph{copy:} Lemásolja az adott változót adott néven
\item \emph{extend:} Megvalósítja az EXTE zárójel funkcióját.
\item \emph{plus:} Megvalósítja a PLUS zárójel funkcióját
\item \emph{get:} Lekérdez egy path-on lévő változót
\item \emph{delete:} Töröl egy path-ról egy változót
\item \emph{accept:} Megvalósítja a visitor patternt
\end{itemize}

Az osztályok mindegyike egyedien épül fel és működik:
\begin{itemize}
\item \emph{SText:} 
Csupán a szöveget tárolja egy String-ben.
\item \emph{SSpec:} 
Egy statikus enumerációban tartalmazza a speciális karakterek értékeit és a kódok listáját, amin az elérhető.
Egy példány csak a kódot tartalmazza String formátumban.
A Plus művelet függ a hozzáadott változó típusától.
A típus feloldására visitor pattern-t használ. 
\item \emph{SSlot:} 
A címkéjét tárolja és egy nullable referenciát a beleszúrt Temp-re. 
\item \emph{STemp:} 
A tartalmát egy mutable Vari listában tárolja.
A cont attribútum lekérdezésekor ebből készít egy SList-et.
Az iter attribútuma az előbb említett SList iter-jét adja vissza. 
Amikor lekérdezik belőle a Text-eket, a Spec-eket vagy a Slot-okat, akkor azt ebből a listából szűri ki mindig újra.
\item \emph{SList:}
Egy mutable List leszármazott.
Template-et használ a beágyazott típus kezelésére.
Egy mutable List-ben tárolja az elemeit.
Minden függvényt felülír és átírányítja a belső Mutable List-nek.
Belső osztályként valósítja meg az SIter-t. 
\item \emph{SType:} 
Egy statikus név szerinti mutable map-ben tárolja a létező típusokat, ami az alap típusokkal inicializálódik.
Amikor egy új típus létrejön, az is regisztrálódik ebbe a listába.
Egy NameType nevű belső adatosztály segíti az attribútumok metaadatainak tárolásában.
\item \emph{SInst:} 
A konstruktora várja a típusa nevét is.
A tartalmát egy nullable Vari-kból álló listában tárolja. 
A lista hossza megegyezik a típus NameType listájáéval.
\item \emph{SFile:}
A változóit egy név szerinti mutable Map-ben tárolja, a kimenetét pedig egy darab String-ben.
\item \emph{SIter:}
A birtokló SList-re referenciája van.
Minden hívást továbbít a birtoklónak vagy az elemeinek.
Ha a birtokló elemeinek továbbít,akkor az eredményt összegzi is. 
\item \emph{SRefe:}
Csak a RegEx mintát tárolja egy String-ben, és a típus megkötést egy List<SType> ban.
Van egy listMatchingPaths függvénye, amin keresztül lekérdezhetőek a rá illeszkedő a megkötéseknek megfelelő változók.
\item \emph{SName:} 
Annyira azonos a funkcionalitása a SText-tel, hogy közvetlenül belőle származik. Nem ír felül semmit.
Csak egy konstruktort tartalmaz, ami STextet konvertál SName-mé.
\end{itemize}

A Cont-oknak nincsen közös ősosztálya.
Mindegyik az SList-et használja.
A Cont típusokat az SList kezeli csak Cont ként.



%----------------------------------------------------------------------------
\section{A fejlesztés fázisai}
\label{sec:SStatesOfDevelopment}
%----------------------------------------------------------------------------
A Slime sok iteráción ment keresztül és még sok iteráción is fog végigmenni. 
A fejlesztés fázisai nagyon tudatos sorrendben követik egymást kisebb-nagyobb átfedésekkel.
Egy olyan nyelv a cél, ami hatékony és mégis könnyen bővíthető.
Mindig figyelemmel követjük ehhez a modern nyelvek szintaxisát és megoldásait.
Idővel szeretnénk minden alapvető funkcionalitást behozni a Slime-ba.
Mérföldkövekről van szó, nem verziókról, mivel az egyes fázisok között lehetnek időbeli átfedések.
Éppen ezért nem is verzió számmal hivatkozunk a fázisokra, hanem a céljukat összefoglaló kódnevekkel.

\begin{itemize}
\item \emph{Eddigi fázisok:}
Ezek azok a fázisok, amiket már meghaladtunk.
Csak absztrakt rétegek magamnak.
Nem jelennek meg sem a giten, sem jegyzetekben.
\begin{itemize}
\item \emph{base:}
Legfőbb célja az alapvető működésnek a megvalósítása volt. 
Csupán a TEXT, SPEC, SLOT, TEMP, DECL, DELE, PLUS és EXTE zárójeleket tartalmazta.
Típusok közül is csak a négy típusjelölő zárójelhez tartozó típusokat jelölte.
Nem volt lehetséges sem importálni, se referenciát használni, sem a neveket manipulálni.
Sokkal inkább volt egy proof of concept, mint valós nyelv. 
Sok jelölés eltért a véglegestől
\item \emph{cont:}
Itt jelent meg a többi típus és zárójel.
Minden a File, Name és Iter kivételével.
Innentől lehetett egy zárójelben több műveletet is végezni.
Már ekkor is a nyelvvel hatékony eredményeket lehetett elérni a redundancia csökkentés terén.
Már itt is működött a \textit{Temp Plus List of Inst} módszer az adatok hatékony tárolására és a Temp-ek
hatékony generálására.
A szintaxison innentől csak igazításokat végeztünk.
A nyelvet innentől minősíthetjük használhatónak.
\item \emph{full:}
Itt jelent meg az Iter, File és Name, illetve itt jelentek meg az egysoros és kompakt zárójelek.
Az eddigi IRTG-generáló kódok harmadukra estek össze.
Innentől a nyelvnek már az összes kezdetektől tervezett funkcionalitása meg van valósítva.
Ekkora alakult ki a szintaxis végleges formája.
Minden jövőbeli szintaxis ezzel már visszafele kompatibilis lesz.
\end{itemize}

\item \emph{Már megtervezett fázisok:}
Azok a funkciók, amik csak az implementálásra várnak.
Csupán a szakdolgozatra jutott időkeret szűkössége miatt nem valósultak meg.
\begin{itemize}
\item \emph{clean:}
A szűk fejlesztési határidő miatt sok ideiglenes megoldás került a nyelvbe.
Ezeknek letisztitására kerül sor az első tervezett fázisban.
A Name típus meg fog szűnni.
Ha Slot-ba Temp-et, Text-et, Slot-ot, Spec-et szúrunk, az az összes tulajdonosában le fogja magát cserélni magát annak a Temp-nek a tartalmára.
A Cont-oknak az implementációban is lesz egy közös őse, az SCont.
Lehetséges lesz egy Slime fájlból több kimeneti fájl generálása.
\item \emph{comf:}
A nyelv kényelmes használatának érdekében sok egyszerűsítés fog történni.
Elhagyhatóak lesznek a a felesleges típusmegadások.
A zárójelek által visszatérített Vari-kból egyből lekérdezhetőek lesznek az attribútumaik. 
Összevonható lesz a négy alapművelet, így minden művelet eredménye egyből kiírható lesz.
\item \emph{test:}
A nyelv teljes tesztlefedettségének megvalósítása.
A tesztfájlokból részletes dokumentáció is készülni fog.
\item \emph{text:}
Ebben a fázisban ki fogjuk bővíteni a szövegkezelési műveleteket.
A szöveget karakterláncként fogjuk látni, és tudni fogjuk kezelni.
A template-eket is szövegként fogjuk látni, ahol minden Spec és Slot egy karakternyi helyet foglal.
Bejön a replace, substring és minden a C nyelvekből ismert String művelet.
\end{itemize}

\item \emph{Távlati tervek:}
Azok a lépések, amik körül már sok párbeszéd történt.
Éppen ezért rendelkeznek kódnévvel is, bár még sok változáson mehetnek keresztül.
Szándék és erőforrás is van arra, hogy megvalósuljanak pár éven belül.

\begin{itemize}
\item \emph{ctrl:}
Be akarjuk vezetni az alap vezérlési elemeket.
Ezekre mindenképp szükség van egy hatékony nyelvhez.
If-else helyett a kotlinos when struktúrából fog kiindulni.
Avagy egy zárójelben lesznek a feltétel- és következménypárok.
Ezek közül fog az első igazra kiértékelődő feltétel következménye teljesülni.
E mellé fog készülni egy if verzió is, ami minden igazra teljesülő feltétel következményét végrehajtja.
Az iterátorokat tovább fejlesztve az alapvető ciklusok minden típusát tartalmazni fogja.
Itt első sorban a lambdás foreach szintaxist fogja követni, de megadható lesz Select és megállási feltétel.
A tároláshoz is be lesznek vezetve új Cont típusok.

\item \emph{dosv:}
Ez a kódnév azt rövidíti, hogy \textit{data oriented slime version}
Fontos, hogy a Slime fordítása hatékony legyen.
Ezért be akarjuk vezetni a data oriented programminget.
Minden eddigi Vari osztály egyesítve lesz egy Vari osztállyá.
Meg lesz valósítva egy saját tároló típus, ami az összes többit helyettesíti.
A legtöbb Vari tulajdonság általánosítva lesz minden típusra.
Például minden típusnak lesz Cont és Iter attribútuma, legfeljebb üres lesz.
Ezektől azt reméljük, hogy sokat fogunk spórolni a típusvizsgálatok és kódismétlések elhagyásával.

\item \emph{vers:}
A letisztított és áthangolt nyelvből több verziót is akarunk készíteni.
Készülni fog egy optimalizált c++20 verzió, mivel sokkal hatékonyabb minden magasabb szintű nyelvnél.
A Python is csak a hátterében lévő C++ könyvtárakkal tud hatékony Deep Learning tool lenni.
Ezt egy Kotlin és c++20 library fogja követni.
Ez azért fontos, hogy a Slime tágabb körben is alkalmazható legyen, így HTML és XML esetben is hatékony eszközzé válik.
A Kotlin verzióból is el lesz hagyva minden túlsúlyos könyvtár.
Ez ugyan azt jelenti, hogy a parszolást is ANTLR nélkül kell megoldani, de egy saját parszer kis áldozat a potenciális teljesítményért.
A Slime-ra az ANTLR által alkalmazottaknál jóval hatékonyabb módszerek is léteznek.
Ez persze főleg a sűrű zárójelezésnek köszönhető.
\end{itemize}

\item \emph{Távlati koncepciók:}
Azok a lépések, amik meghaladják a jelenlegi erőforrásokat: vagy túl sok időt, vagy túl bonyolult módosításokat igényelnek.
Éppen ezért csak sokadlagos jelentőséggel bírnak, ugyanakkor még így is hatással vannak a nyelvre.
Amikor két túl hasonló design-irány között kell dönteni, ezeknek a funkcionalitásoknak a tervezett bevezetését is szem előtt tartjuk.
Ilyenkor kényelmes a döntést a koncepció kódnevével indokolni.
\begin{itemize}
\item \emph{alge:}
A template-elés folyamata felfogható egy fa felépítéseként is, ahol a csúcsok a sablonok, és a csúcsoknak annyi gyermeke lehet, ahány mező van a sablonban.
Ebben az ismétlődő részfákat összevonva már egy irányított körmentes gráfot kezelünk.
Ezért hasznos lenne bevezetni egy saját gráfalgebrát, ami az SGA javítása lesz.
Ezeknek bejárására és kezelésére is számos módot tesz majd lehetővé a Slime.
Ezen kívül az indexek és más számadatok is nehezen kezelhetőek a Slime-ban.
Hasznos lenne, ha a számokat kezelni lehetne.
Ez történhetne lebegőpontos és egészként is.
A Slime irányzatát követve nyilván célszerűbb lesz egy típussal kezelni a számokat. 
\item \emph{func:}
Hasznos lenne egy függvényszerű mechanizmus, sokat csökkentene a Slime redundanciáján.
Ennek lényege az lenne, hogy a Slime kódot tároló Temp-ek (vagy azok alpján nyugvó új osztály) futtathatóak lesznek.
Ez azt jelenti, hogy hívásnál a függvény bemeneteit beillesztjük a slotokba és futtatjuk a kimenetet fájlként.
Ez a névterekkel és Inst-ekkel együtt már egy osztályok fele hajló struktúrát fog alkotni.
\item \emph{irtg:}
Lehetséges lesz template-elés szinkronizálása környezetfüggetlen nyelvtanokkal.
Ez azt jelentené, hogy a Slime egy az IRTG-t meghaladó nyelv lesz, ami az IRTG funkcionalitásait is megvalósítja.
Ezeknek a funkcionalitásoknak a használata viszont nem lesz kötelező, így továbbra is függetlenek maradunk az IRTGtől.
A többféle algebra kimenetét lehetséges lesz külön fájlba, vagy más bemenetre irányítani.
\end{itemize}

\end{itemize}

Természetesen ezek a fázisok minél nagyobb távra mutatnak, annál rugalmasabbak.
Ugyanakkor fontos irányvonalakat szemléltetnek, és jól mutatják a projekt mögötti ambíciót.



%----------------------------------------------------------------------------
\section{Példák a Slime alkalmazására}
\label{sec:SExamples}
%----------------------------------------------------------------------------

A nyelv elsődleges célja az IRTG kiegészítése volt, de ennél több helyen is hatékonynak bizonyult.
Az IRTG-n kívül a nyelv jól használható az ANTLR nyelvtanain, HTML kódokon és XML kódokon.
Ezeket kívánom bemutatni alap példákon.


%----------------------------------------------------------------------------
\subsection{IRTG}
\label{sec:SEIRTG}
%----------------------------------------------------------------------------
Mivel az IRTG volt a fő célpontunk, ebből készült a legtöbb példakód.
IRTG-n teszteltük a nyelv szintaxisát és működését.
Ezen szemléltettük a különböző szintű műveleteket.
A nyelvtanok közül hármat kívánok bemutatni.
Mind a három ugyanazt a feladatot látja el, de a nyelv más szintjén.

Az első nyelvtan közvetlen a base fázis utáni állapothoz készült.
Csak a legalapvetőbb zárójeltípusokat tartalmazta, például tárolókból is kizárólag a Temp-et.\footnote{\url{https://github.com/Hollo1996/SlimeAnUTLE/blob/master/test_codes/irtg_example1}}

A második már a nyelvet egy mechanikailag fejlett szinten mutatja be.
Az adatokat is külön fájlba rendezi.
Szintaxisból viszont csak a legalapvetőbb megoldásokat tartalmazza.\footnote{\url{https://github.com/Hollo1996/SlimeAnUTLE/blob/master/test_codes/irtg_example2}},\footnote{\url{https://github.com/Hollo1996/SlimeAnUTLE/blob/master/test_codes/irtg_example2data}}
Fontos! Az első fájl a másodikat a Slime programhoz viszonyított \texttt{../test\_codes/irtg\_example2data} mappában keresi.
Ha nem ennek megfelelően helyezzük el a második fájlt, akkor nem lesz sikeres a futtatás.

A harmadik megoldás a fejlett szintaxis szemléltetését célozza meg.
Az adatokat egy fájlban tárolja a műveletekkel, de egy sokkal tömörebb formában.
Alkalmaz minden elérhető funkciót a Slime-ból, ami indokolt.\footnote{\url{https://github.com/Hollo1996/SlimeAnUTLE/blob/master/test_codes/irtg_example3}}

Ezeken kívül jelenleg is dolgozunk egy megoldáson, hogy beépítjük a Slime-ot a jelenlegi IRTG generátorba.
Itt a generált nyelvtan átlátását segíti elsősorban.
A példa a két gyermekű NP-kre íródott és adata ezeknek egy pici részhalmazát fedi le.
A legfejlettebb szintaxist és módszereket használja.\footnote{\url{https://github.com/Hollo1996/SlimeAnUTLE/blob/master/test_codes/irtg_example4}}

%----------------------------------------------------------------------------
\subsection{ANTLR}
\label{sec:SEANTLR}
%----------------------------------------------------------------------------
Az ANTLR esetében a legkézreesőbb példát hozom, a Slime \texttt{lexer} nyelvtanát. 
Ezen ugyan tudtunk egyszerűsíteni, de amennyit nyertünk, annyit vesztettünk a parszer egyszerűsítéséhez bevezetett type() műveletekkel.
A lexeren belül is egy kisebb részt, a nyitó és csukó speciális zárójelek szabályait fogom leírni.\footnote{\url{https://github.com/Hollo1996/SlimeAnUTLE/blob/master/test_codes/antlr_example}}

Így ezek a kódrészek közel negyedükre estek össze.


%----------------------------------------------------------------------------
\subsection{HTML}
\label{sec:SEHTML}
%----------------------------------------------------------------------------
A HTML-ek hatékony kezelésére számos templater engine létezik.
Mivel specialitásuk, a HTML-re általánosan hatékonyabbak is a Slime-nál.
Ennek elsődleges oka az, hogy elérhetőek libraryként egy magasabb nyelvből, és onnan vezérelhetőek, vagy egy magasabb nyelv ágyazható beléjük.
Ebben a példában azt kívánom szemléltetni, hogy a kész adatok esetén, hogyan érhetőek el a Mustache-hoz hasonló technikák.\footnote{\url{https://github.com/Hollo1996/SlimeAnUTLE/blob/master/test_codes/html_example}}

Hiszek benne, hogy a Slime hamar versenyképes lesz más templater engine-ekkel szemben is.
Nem cél egy, az összes többinél hatékonyabb megoldást nyújtani.
A cél egy univerzális, könnyen tanulható megközelítése a feladatnak.


%----------------------------------------------------------------------------
\subsection{XML}
\label{sec:SEXML}
%----------------------------------------------------------------------------
 XML-lel gyakran találkozunk Android fejlesztés terén.
 Egyes gombos menük esetén is nagyon hasonló beállításokkal látjuk el a gombjainkat.
 Ezeket pedig, ha csak nem szervezzük külső fájlokba, akkor minden egyes gomb esetén kötelesek vagyunk megadni.
 Ez Slime-mal is elkerülhető.\footnote{\url{https://github.com/Hollo1996/SlimeAnUTLE/blob/master/test_codes/xml_example}}



